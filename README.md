# LeetCode
## [1367.二叉树中的列表](https://github.com/artintel/LeetCode/blob/master/1367.%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E5%88%97%E8%A1%A8/main.cpp)
> 如果数组是单调递增或单调递减的，那么它是单调的。
>
> 如果对于所有 i <= j，A[i] <= A[j]，那么数组 A 是单调递增的。 如果对于所有 i <= j，A[i]> = A[j]，那么数组 A 是单调递减的。
>
> 当给定的数组 A 是单调数组时返回 true，否则返回 false。
>
> 来源：力扣（LeetCode）
> 链接：https://leetcode-cn.com/problems/monotonic-array
> 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

> 参考自：
> 作者：LeetCode-Solution
> 链接：https://leetcode-cn.com/problems/linked-list-in-binary-tree/solution/er-cha-shu-zhong-de-lie-biao-by-leetcode-solution/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## [92. 反转链表 II，暴力求解](https://github.com/artintel/LeetCode/blob/master/92.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8II/Mycode.cpp)

> 先用两个指针通过移动分别找到 m 的前一个位置结点和 n 的当前节点。
>
> 为避免出现在1个节点出现的相应情况，选择`new`了一个头节点，该节点的下一个节点指向 `head`
>
> 在找到对应的两个节点位置后，将该段节点倒置，再连接起来

## [138. 复制带随机指针的链表](https://github.com/artintel/LeetCode/blob/master/138.%20%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/138source_code.cpp)

> 给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。
>
> 要求返回这个链表的 **深拷贝** 
>
> 我们用以一个由 `n` 个节点组成的链表表示输入、输出中的链表。每个节点用一个 `[val, random_index]` 表示
>
> - `val`: 一个表示 `Node.val` 的整数
> - `random_index`: 随机指针指向的节点索引(0~n-1)；如果不指向任何节点，则为 `nullptr`。
>
> ```c++
> 输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
> 输出：[[7,null],[13,0],[11,4],[10,2],[1,0]]
> ```
>
> 我的想法很粗糙，就是新建了两个vector，分别用来按顺序储存原链表和new 新的链表，同时接上next指针，这样需要做的就只有random指针了，那么再通过 `find() 和 distance()` 两个函数来查找到 random 指向的位置，再在new出来的数组中进行链接。 很暴力，当以后有了更好的想法后再更新

## [725. 分隔链表](https://github.com/artintel/LeetCode/blob/master/725.%20%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/725.%20%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8.cpp)

> 给定一个头结点为 root 的链表, 编写一个函数以将链表分隔为 k 个连续的部分。
>
> 每部分的长度应该尽可能的相等: 任意两部分的长度差距不能超过 1，也就是说可能有些部分为 null。
>
> 这k个部分应该按照在链表中出现的顺序进行输出，并且排在前面的部分的长度应该大于或等于后面的长度。
>
> 返回一个符合上述规则的链表的列表。
>
> 举例： 1->2->3->4, k = 5 // 5 结果 [ [1], [2], [3], [4], null ]
>

> 重点在于怎么分配这个数量 --> k 代表一共需要分成多少组，len 代表链表一共有多少个节点
>
> 先考虑简单的情况
>
> 1.  当 `k == len`, 说明每一组刚好一个节点，直接用 `vector<ListNode*> ans` 接收节点，需要注意的是，每个节点的 `next` 需要记得 ->nullptr
> 2.  当 `k > len`, 说明在 `k == len` 的基础上，后续需要扩张 `k - len` 个空间，并置为 `nullptr`
> 3. 当 `k == 1`, 我的代码写法应为已经在之前就已经放进了`ans`，所以直接 `ans.resize(1);` 即可
> 4. 当 `k < len`:
>    1. 首先需要知道每组有多少节点 用 `divid = len / k;` 接收
>    2. 然后就是需要知道有多少组需要添加额外的一个节点，因为任意两组之间的结点数量差距不能超过1，那么用 `divid_mood = len % k;`
>    3. 然后就和上面的操作基本差不多了，需要注意的也就是注意每一组的最后一个结点的 `node->next = nullptr;`
>    4. 最后 `return`

> 写法很不美，事情太多，暂时就不去细扣进阶的操作和细化了。

## [817. 链表组件](https://github.com/artintel/LeetCode/blob/master/817.%20%E9%93%BE%E8%A1%A8%E7%BB%84%E4%BB%B6/source_code.cpp)

> 给定链表头结点 head，该链表上的每个结点都有一个 唯一的整型值 。
>
> 同时给定列表 G，该列表是上述链表中整型值的一个子集。
>
> 返回列表 G 中组件的个数，这里对组件的定义为：链表中一段最长连续结点的值（该值必须在列表 G 中）构成的集合。
>

> 当时看题有点没看懂，花了时间。其实也就是从 `head` 节点顺序遍历，如果当前节点在列表 `G` 中没有被发现，就说明发生了中断，通过 `flag` 来判定是否需要对组件个数进行增加1的操作，也就是说，发生查找失败前是否存在有连续或者单个的节点，如果有就自增1，反之不增加。考虑通过`hash`来减少时间复杂度
>
> 再次熟悉了 `unordered_set<T> object, object.find(), object.insert()` 函数

## [109. 有序链表转换二叉搜索树](https://github.com/artintel/LeetCode/blob/master/109.%20%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/source_code.cpp)

> 给定一个单链表，其中的元素按升序排序，将其转换为高度平衡的二叉搜索树。
>
> 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。
>
> 示例:
>
> 给定的有序链表： [-10, -3, 0, 5, 9],
>
> 一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：
>
>   ​         0
>      	  / \
>    ​	  -3   9
>    ​	  /    /
>     -10  5

> 了解参考了官方的解答。重点在于该有序链表本身就可以看做是二叉树的中序遍历。通过找到中位数的位置，来进行二叉搜索树的构建。
>
> ```c++
> TreeNode* root = new TreeNode();
> root->left = buildTreeNode(head, left, mid - 1);
> root->val = head->val;//左子树已经构建完毕，head已经到达了中位节点，实际就是根节点
> head = head->right;//构建右子树
> root->right = buildTreeNode(head, mid + 1, right);
> ```

## [剑指 Offer 18. 删除链表的节点](https://github.com/artintel/LeetCode/blob/master/%E5%89%91%E6%8C%87%20Offer%2018.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/source_code.cpp)

> 给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。
>
> 返回删除后的链表的头节点
>
> ```输入: head = [4,5,1,9], val = 5
> 输出: [4,1,9]
> 解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
> ```

## [剑指 Offer 22. 链表中倒数第k个节点](https://github.com/artintel/LeetCode/blob/master/%E5%89%91%E6%8C%87%20Offer%2022.%20%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/source_code.cpp)

> 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。
>
> ```输入: head = [4,5,1,9], val = 5
> 给定一个链表: 1->2->3->4->5, 和 k = 2.
> 
> 返回链表 4->5.
> ```

## [剑指 Offer 24. 反转链表](https://github.com/artintel/LeetCode/blob/master/%E5%89%91%E6%8C%87%20Offer%2024.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/source_code.cpp)

> 定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点
>
> ```输入: head = [4,5,1,9], val = 5
> 输入: 1->2->3->4->5->NULL
> 输出: 5->4->3->2->1->NULL
> ```

## [面试题 02.02. 返回倒数第k个节点](https://github.com/artintel/LeetCode/blob/master/%E9%9D%A2%E8%AF%95%E9%A2%98%2002.02.%20%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/source_code.txt)

> 实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。

> ```
> 输入： 1->2->3->4->5 和 k = 2
> 输出： 4
> ```

## [面试题 02.04. 链表求和](https://github.com/artintel/LeetCode/blob/master/%E9%9D%A2%E8%AF%95%E9%A2%98%2002.05.%20%E9%93%BE%E8%A1%A8%E6%B1%82%E5%92%8C/source_code.cpp)

> 给定两个用链表表示的整数，每个节点包含一个数位。
>
> 这些数位是反向存放的，也就是个位排在链表首部。
>
> 编写函数对这两个整数求和，并用链表形式返回结果。

> ```
> 输入：(7 -> 1 -> 6) + (5 -> 9 -> 2)，即617 + 295
> 输出：2 -> 1 -> 9，即912
> ```
>
> 思路: 我定义了一个 `J` 也就是记录相加的进位,初始为 0
>
> 然后分为三个情况
>
> 1. `l1 != nullptr && l2 != nullptr` 那么就只需要同时相加，并且将进位也加上。同时更新新的进位 `J`
>
>    ```C++
>    sum = new ListNode(l1->val + l2->val + J) % 10;
>    J = (l1->val + l2->val + J) / 10;
>    ```
>    
> 2. `l1 != nullptr && l2 == nullptr`
>
> 3. `l1 == nullptr && l2 == nullptr`
>
> 4. 最后还要考虑两个链表都结束过后，进位 `J != 0`
>
>    ```C++
>    sum = new ListNode(J);
>    ```
>
> 最后，将所有节点连起来即可。

> **进阶：**思考一下，假设这些数位是正向存放的，又该如何解决呢?

>  ```
>  输入：(6 -> 1 -> 7) + (2 -> 9 -> 5)，即617 + 295
>  输出：9 -> 1 -> 2，即912
>  ```

> 用栈

## [面试题 02.03. 删除中间节点](https://github.com/artintel/LeetCode/blob/master/%E9%9D%A2%E8%AF%95%E9%A2%98%2002.03.%20%E5%88%A0%E9%99%A4%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/source_code.cpp)

> 实现一种算法，删除单向链表中间的某个节点（即不是第一个或最后一个节点），假定你只能访问该节点。

> ```
> 输入：单向链表a->b->c->d->e->f中的节点c
> 结果：不返回任何数据，但该链表变为a->b->d->e->f
> ```

## [面试题 02.07. 链表相交](https://github.com/artintel/LeetCode/blob/master/%E9%9D%A2%E8%AF%95%E9%A2%98%2002.07%20%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4/source_code.cpp)

> 给定两个（单向）链表，判定它们是否相交并返回交点。请注意相交的定义基于节点的引用，而不是基于节点的值。换句话说，如果一个链表的第k个节点与另一个链表的第j个节点是同一节点（引用完全相同），则这两个链表相交。
>

> ```
> 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
> 输出：Reference of the node with value = 8
> 输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
> ```

> 简单题，考虑双指针(还有其他的算法，没有去做)。
>
> 两个指针 `followA = headA; followB = headB` ,直接相遇就输出，否则 判断是否走到头
>
> ```C++
> followA ? followA = followA->next : followA = headB;
> followB ? followB = followB->next : followB = headA;
> ```

## [面试题 02.01. 移除重复节点](https://github.com/artintel/LeetCode/blob/master/%E9%9D%A2%E8%AF%95%E9%A2%98%2002.01.%20%E7%A7%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E8%8A%82%E7%82%B9/source_code.cpp)

> 编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。

> ```
> 输入：[1, 2, 3, 3, 2, 1]
> 输出：[1, 2, 3]
> ```

> 考虑用哈希map保存值`<int, int> (val, 0)`，每次检查代删除点是否已经存在:
>
> ```
> if (map[val] == 0) {
> 	map[val] = 1;
> 	pre->next = cur;
> 	pre = pre->next;
> 	cur = cur->next;
> }
> esle{
> 	cur = cur->next;
> }
> ```
>
> 由此即可删除重复点。

## [6. Z 字形变换](https://github.com/artintel/LeetCode/blob/master/6.%20Z%20%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/source_code.cpp)

> 将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。
>
> 比如输入字符串为 `"LEETCODEISHIRING"` 行数为 3 时，排列如下：

> ```
> L   C   I   R
> E T O E S I I G
> E   D   H   N
> ```

> 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：`"LCIRETOESIIGEDHN"`。
>
> 请你实现这个将字符串进行指定行数变换的函数：
>
> ```C++
> string convert(string s, int numRows);
> ```
>
> **示例 1:** 
>
> ```C++
> 输入: s = "LEETCODEISHIRING", numRows = 3
> 输出: "LCIRETOESIIGEDHN"
> ```
>
> **示例 2:** 
>
> ```C++
> 输入: s = "LEETCODEISHIRING", numRows = 4
> 输出: "LDREOEIIECIHNTSG"
> 解释:
> 
> L     D     R
> E   O E   I I
> E C   I H   N
> T     S     G
> ```
>
> 题解来自官方。第一个解的方法在于用`bool goingDown = true or false 来进行Z字形赋值` 很厉害
>
> 第二种方法就是
>
> **思路**
>
> 按照与逐行读取 Z 字形图案相同的顺序访问字符串。
>
> **算法**
>
> 首先访问行 0 中的所有字符，接着访问行 1，然后行 2，依此类推...
>
> 对于所有整数 `k`，
>
> - 行 0 中的字符位于索引 `k * (2 * numRows - 2) `处;
> - 行 `numRows-1 `中的字符位于索引 `k* (2 * numRows - 2) + numRows - 1 `处;
> - 内部的 行 `i` 中的字符位于索引 `k * (2 * numRows-2) + i `以及`(k+1)(2 * numRows - 2) - i `处;
>

## [面试题 02.06. 回文链表](https://github.com/artintel/LeetCode/blob/master/%E9%9D%A2%E8%AF%95%E9%A2%98%2002.06.%20%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/source_code.cpp)

> 编写一个函数，检查输入的链表是否是回文的。

> ```
> 输入： 1->2
> 输出： false 
> ```

> 用快慢指针找到中间节点的前一个节点，从中间断开，前面一般的链表入栈，进行比较
>
> ```C++
> while(!ans.empty()){
> 	if (ans.top() != fast->val) break;
>     ans.pop();
>     fast = fast->next;
> }
> return ans.empty() ? true : false;
> ```

## [面试题 02.08. 环路检测](https://github.com/artintel/LeetCode/blob/master/%E9%9D%A2%E8%AF%95%E9%A2%98%2002.08.%20%E7%8E%AF%E8%B7%AF%E6%A3%80%E6%B5%8B/source_code.cpp)

> 给定一个链表，如果它是有环链表，实现一个算法返回环路的开头节点。
>
> 如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 `0` 开始）。 如果 `pos` 是 `-1`，则在该链表中没有环。注意：`pos` 不作为参数进行传递，仅仅是为了标识链表的实际情况
>

> ```
> 输入：head = [3,2,0,-4], pos = 1
> 输出：tail connects to node index 1
> 解释：链表中有一个环，其尾部连接到第二个节点。
> ```

> (自己的方法简单暴力：`unordered_set<ListNode*>`, 来逐个保存节点，每次保存之前通过`set.count(head)`,来判断是否已经有相同的节点在里面了，如果有就说明找到了环路，并且找到了环路的入口，如果遇到`head == nullptr`，则说明没有环路，返回`nullptr`)

> 大佬的方法：数学证明：
>
> 如果链表中有环，那么快慢指针就一定可以相遇（且一定再环上，如图上的c点），此时快指针移动过的距离是慢指针的2倍，根据图中的参数，我们可以写出以下等式：
>
> ```mathematica
> (m+y)*2=m+xn+y
> ```
>
> 这里的 `xn` 是当相遇时快指针已经在环上循环了 `x` 次，` x>=1` 且为整数
>
> ```mathematica
> m+y=xn => m=n-y+(x-1)*n
> ```
>
> 下面解释为什么写成这种形式
>
> 接下来将快指针置于表头(此时快指针在 `a` 处，慢指针在 `c` 处)，与慢指针以相同速度在链表上移动，当快指针移动到 `b` 处时，移动了 `m` 的距离，根据上面的等式可知，慢指针移动了
>
> ```mathematica
> n-y+(x-1)*n
> ```
>
> 的距离。
>
> 我们来分析一下此时的慢指针在什么位置：
> 先移动 `(x-1)*n` 的距离，相当于在环上循环了 `(x-1)` 次，慢指针又回到了 `c` 点，然后再移动 `n-y` 的距离，如图所示，`n-y` 正好是 `c` 点到 `b` 点的距离，说明此时慢指针也移动到了 `b` 点，即快慢指针在环路的开头节点相遇了。
>
> 来源：力扣（LeetCode）https://leetcode-cn.com/u/chen-hui-d/ 晨辉
> 链接：https://leetcode-cn.com/problems/linked-list-cycle-lcci/solution/kuai-man-zhi-zhen-zheng-ming-bi-jiao-yan-jin-by-ch/

## [面试题 02.04. 分隔链表](https://github.com/artintel/LeetCode/blob/master/%E9%9D%A2%E8%AF%95%E9%A2%98%2002.04.%20%E5%88%86%E9%9A%94%E9%93%BE%E8%A1%A8/source_code.cpp)

> 编写程序以 x 为基准分割链表，使得所有小于 x 的节点排在大于或等于 x 的节点之前。如果链表中包含 x，x 只需出现在小于 x 的元素之后(如下所示)。分割元素 x 只需处于“右半部分”即可，其不需要被置于左右两部分之间。
>

> ```
> 输入: head = 3->5->8->5->10->2->1, x = 5
> 输出: 3->1->2->10->5->5->8
> ```

> 实际只需要考虑 `node->val < x` 的节点即可，将所有满足条件的节点用另一条链表连接，最后将两个列表连接在一起，即可

## [430. 扁平化多级双向链表](https://github.com/artintel/LeetCode/blob/master/430.%20%E6%89%81%E5%B9%B3%E5%8C%96%E5%A4%9A%E7%BA%A7%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/source_code.cpp)

> 多级双向链表中，除了指向下一个节点和前一个节点指针之外，它还有一个子链表指针，可能指向单独的双向链表。这些子列表也可能会有一个或多个自己的子项，依此类推，生成多级数据结构，如下面的示例所示。
>
> 给你位于列表第一级的头节点，请你扁平化列表，使所有结点出现在单级双链表中。
>

> ```
> 输入：head = [1,2,3,4,5,6,null,null,null,7,8,9,10,null,null,11,12]
> 输出：[1,2,3,7,8,11,12,9,10,4,5,6]
> ```

> 可以竖向的看，就能看出是很简单的二叉树的数据结构，再经过前序遍历，通过一个STL的队列数据结构。将节点一次放入队列中，最后再通过
>
> ```C++
> while(!ans.empty()){
>     temp = ans.front();
>     ans.pop();
>     if(ans.empty()) break;
>     else{
>         temp->next = ans.front();
>         ans.front()->prev = temp;
>         temp->child = nullptr;
>     }
> }
> temp->next = nullptr;
> temp->child = nullptr;
> ```
>
> 就可以完成扁平化双向链表。

## [23. 合并K个升序链表](https://github.com/artintel/LeetCode/blob/master/23.%20%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/source_code.cpp)

> 给你一个链表数组，每个链表都已经按升序排列。
>
> 请你将所有链表合并到一个升序链表中，返回合并后的链表。

> ```
> 输入：lists = [[1,4,5],[1,3,4],[2,6]]
> 输出：[1,1,2,3,4,4,5,6]
> 解释：链表数组如下：
> [
>   1->4->5,
>   1->3->4,
>   2->6
> ]
> 将它们合并到一个有序链表中得到。
> 1->1->2->3->4->4->5->6
> 
> 输入：lists = []
> 输出：[]
> 
> 输入：lists = [[]]
> 输出：[]
> ```

> 自己的思路:顺序地两两合并。但是效率很差
>
> 官方思路:
>
> 1. 分治法
> 2. 队列合并

## [25. K 个一组反转链表](https://github.com/artintel/LeetCode/blob/master/25.%20K%E4%B8%AA%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/source_code.cpp)

> 给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。
>
> k 是一个正整数，它的值小于或等于链表的长度。
>
> 如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。
>
> ```
> 给你这个链表：1->2->3->4->5
> 
> 当 k = 2 时，应当返回: 2->1->4->3->5
> 
>   当 k = 3 时，应当返回: 3->2->1->4->5
>   ```

> 解题思路：
>
> 考虑将每 K 个一组的子链表单独拿出来进行反转。那么就需要考虑反转后和前序后缀的连接。因此定义了如下的中转变量
>
> ```c++
> //new 一个新的头节点，next指向head
> ListNode* Head = new ListNode(-1);
> //定义一个计数器m,查看是否有m个结点进入
> int m = 1;
> //定义一个指针指向每段要进行反转的子链表的直接前序。
> ListNode* pre = Head;
> //定义一个指针指向子链表的头节点
> ListNode* behind = head;
> //定义一个当前的位置的指针
> ListNode* cur = head;
> //定义一个指向子链表的直接后缀
> ListNode* tail;
> ```

## [26. 删除排序数组中的重复项](https://github.com/artintel/LeetCode/blob/master/26.%20%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/source_code.cpp)

> 给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。
>
> 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。
>

> ```
> 给定数组 nums = [1,1,2], 
> 
> 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 
> 
> 你不需要考虑数组中超出新长度后面的元素。
> ```

> 用一个 left 一直指在重复数值的第一个(也可以理解成新的子数组的最后一个值)
> 用for循环遍历过程的 i 作为第二个“指针”，当遇到和left指的数值不一样的时候，
> `nums[left + 1] = nums[i];`
> 遍历结束 `nums.resize(left + 1);`
> `return left + 1`;

## [27. 移除元素](https://github.com/artintel/LeetCode/blob/master/27.%20%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0/source_code.cpp)

> 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
>
> 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。
>
> 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
>

> ```
> 给定 nums = [3,2,2,3], val = 3,
> 
> 函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。
> 
> 你不需要考虑数组中超出新长度后面的元素。
> ```

> 双指针：用 `pre` 指在新数组的最后一个，有 `behind` 来遍历数组，当遇到 `nums[behind] != val;` 时，就将 `behind` 所指元素放入到 `pre`位置

## [35. 搜索插入位置](https://github.com/artintel/LeetCode/blob/master/35.%20%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/source_code.cpp)

> 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
>
> 你可以假设数组中无重复元素。

> ```
> 输入: [1,3,5,6], 5
> 输出: 2
> 输入: [1,3,5,6], 2
> 输出: 1
> 输入: [1,3,5,6], 7
> 输出: 4
> 输入: [1,3,5,6], 0
> 输出: 0
> ```

> 二分查找

## [53. 最大子序和](https://github.com/artintel/LeetCode/blob/master/53.%20%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/source_code.cpp)

> 给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

> ```
> 输入: [-2,1,-3,4,-1,2,1,-5,4]
> 输出: 6
> 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
> ```

> - 动态规划， 分别定义了 temp 记录以当前位置为结点的最大序列和是多少， max 记录真正最大的和；
>
>    ```C++
>    for(const auto& x : nums){
>        temp = max(temp + x, x);
>        MAX = max(temp, MAX);
>    }
>    ```
>
> - 分治法：
>
>   思路和算法
>
>   我们定义一个操作 `get(a, l, r)` 表示查询 `a` 序列 `[l, r]` 区间内的最大子段和，那么最终我们要求的答案就是 `get(nums, 0, nums.size() - 1)`。如何分治实现这个操作呢？对于一个区间 `[l, r]`，我们取 $m = \lfloor \frac{l + r}{2} \rfloor m =⌊ 2 \cdot l+r ⌋$，对区间 `[l, m]` 和 `[m + 1, r]` 分治求解。当递归逐层深入直到区间长度缩小为 11 的时候，递归「开始回升」。这个时候我们考虑如何通过 `[l, m]` 区间的信息和 `[m + 1, r]` 区间的信息合并成区间 `[l, r]` 的信息。最关键的两个问题是：
>   
>   - 我们要维护区间的哪些信息呢？
>   
>   - 我们如何合并这些信息呢？
>   
>   对于一个区间 `[l, r]`,  我们可以维护四个量：
>   
>   - lSum 表示 `[l, r]` 内以 ll 为左端点的最大子段和
>   
>   - rSum 表示 `[l, r]` 内以 rr 为右端点的最大子段和
>   
>   - mSum 表示 `[l, r]` 内的最大子段和
>   
>   - iSum 表示 `[l, r]` 的区间和
>   
>   以下简称 `[l, m]` 为 `[l, r]` 的「左子区间」， `[m + 1, r]` 为 `[l, r]` 的「右子区间」。我们考虑如何维护这些量呢（如何通过左右子区间的信息合并得到 `[l, r]` 的信息）？对于长度为 1 的区间 `[i, i]` ，四个量的值都和 $ a_i $ 相等。对于长度大于 1 的区间：
>   
>   - 首先最好维护的是 `iSum`，区间 `[l, r]` 的 `iSum` 就等于「左子区间」的 `iSum` 加上「右子区间」的 `iSum`。
>   - 对于 `[l, r]` 的 `lSum`，存在两种可能，它要么等于「左子区间」的 `lSum`，要么等于「左子区间」的 `iSum` 加上「右子区间」的 `lSum`，二者取大。
>   - 对于 `[l, r]` 的 `rSum`，同理，它要么等于「右子区间」的 `rSum`，要么等于「右子区间」的 `iSum` 加上「左子区间」的 `rSum`，二者取大。
>   - 当计算好上面的三个量之后，就很好计算 `[l, r]` 的 `mSum` 了。我们可以考虑 `[l, r]` 的 `mSum` 对应的区间是否跨越 `m` ——它可能不跨越 `m`，也就是说 `[l, r]` 的 `mSum` 可能是「左子区间」的 `mSum` 和 「右子区间」的 `mSum` 中的一个；它也可能跨越 `m`，可能是「左子区间」的 `rSum` 和 「右子区间」的 `lSum` 求和。三者取大。
>   
>   作者：LeetCode-Solution
>   链接：https://leetcode-cn.com/problems/maximum-subarray/solution/zui-da-zi-xu-he-by-leetcode-solution/
>   来源：力扣（LeetCode）
>   著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
> 

## [66. 加一](https://github.com/artintel/LeetCode/blob/master/66.%20%E5%8A%A0%E4%B8%80/source_code.cpp)

> 给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。
>
> 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。
>
> 你可以假设除了整数 0 之外，这个整数不会以零开头。
>

> ```
> 输入：digits = [1,2,3]
> 输出：[1,2,4]
> 解释：输入数组表示数字 123。
> 
> 输入：digits = [0]
> 输出：[1]
> ```

## [88. 合并两个有序数组](https://github.com/artintel/LeetCode/blob/master/88.%20%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/source_code.cpp)

> 给你两个有序整数数组 *nums1* 和 *nums2*，请你将 *nums2* 合并到 *nums1* 中*，*使 *nums1* 成为一个有序数组。

> - 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。
> - 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。

> ```
> 输入：
> nums1 = [1,2,3,0,0,0], m = 3
> nums2 = [2,5,6],       n = 3
> 
> 输出：[1,2,2,3,5,6]
> ```

> 先用额外的 `vector<int> num` 拷贝 `nums1`, 双指针分别遍历 `nums1, nums2`, 将值小的放入 `nums1`， 因为 `nums1`已被复制，所以无须考虑`nums1` 内的值是否被占用所以是安全的

## [118. 杨辉三角](https://github.com/artintel/LeetCode/blob/master/118.%20%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/source_code.cpp)

> 给定一个非负整数 *numRows，*生成杨辉三角的前 *numRows* 行。

> ```
> 输入: 5
> 输出:
> [
>      [1],
>     [1,1],
>    [1,2,1],
>   [1,3,3,1],
>  [1,4,6,4,1]
> ]
> ```

> 1. vector<vector<int> > ans;
>
> 2. vector<int> temp;
>
> 3. ```
>    while(cur <= i){
>        if(cur == 0 || cur == i){
>        temp.emplace_back(1);
>        cur++;
>    }
>    else{
>        temp.emplace_back(ans[i - 1][cur - 1] + ans[i - 1][cur]);
>        cur++;
>        }
>    }
>    ans.emplace_back(temp);
>    ```
>

## [119. 杨辉三角II](https://github.com/artintel/LeetCode/blob/master/119.%20%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92II/source_code.cpp)

> 给定一个非负索引 *k*，其中 *k* ≤ 33，返回杨辉三角的第 *k* 行。

> ```
> 输入: 3
> 输出: [1,3,3,1]
> ```

> 动态规划
>
> ```C++
> vector<int> dp(rowIndex + 1, 1);
>     for (int i = 1; i <= rowIndex; i++) {
>         for (int j = i - 1; j >= 1; j--) {
>             dp[j] = dp[j - 1] + dp[j];
>         }
>     }
> ```
>
> 这个优化可以将空间复杂度控制为 O(k)；

## [121. 买卖股票的最佳时机](https://github.com/artintel/LeetCode/blob/master/121.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/source_code.cpp)

> 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
>
> 如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。
>
> 注意：你不能在买入股票前卖出股票。
>

> ```
> 输入: [7,1,5,3,6,4]
> 输出: 5
> 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
>      注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。
> ```

> ```C++
> 输入: [7,6,4,3,1]
> 输出: 0
> 解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。vector<int> dp(rowIndex + 1, 1);
>     for (int i = 1; i <= rowIndex; i++) {
>         for (int j = i - 1; j >= 1; j--) {
>             dp[j] = dp[j - 1] + dp[j];
>         }
>     }
> ```

## [122. 买卖股票的最佳时机 II](https://github.com/artintel/LeetCode/blob/master/122.%20%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%20II/source_code.cpp)

> 给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
>
> 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
>
> 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
>

> ```
> 输入: [7,1,5,3,6,4]
> 输出: 7
> 解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
>      随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。
> ```

> ```
> 输入: [1,2,3,4,5]
> 输出: 4
> 解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
>      注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
>      因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。
> ```

> 思路同121

## [167. 两数之和 II - 输入有序数组](https://github.com/artintel/LeetCode/blob/master/167.%20%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C%20II-%20%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/source_code.cpp)

> 给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。
>
> 函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。
>

> ```
> 输入: numbers = [2, 7, 11, 15], target = 9
> 输出: [1,2]
> 解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 
> ```

> 思路：
>
> 先用二分查找发找到不大于 target 的值的 Index, 用双指针分别指向数组起点和 index。如此，分为了三种情况
>
> 1. ```C++
>    if(numbers[i] + numbers[j] == target){
>        ans.emplace_back(min(i, j) + 1);
>        ans.emplace_back(max(i, j) + 1);
>        break;
>    }
>    ```
>
> 2. ```C++
>    else if (numbers[i] + numbers[j] > target){
>        j--;
>    }
>    ```
>
> 3. ```C++
>    else i++;
>    ```

## [169. 多数元素](https://github.com/artintel/LeetCode/blob/master/169.%20%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/source_code.cpp)

> 给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。
>
> 你可以假设数组是非空的，并且给定的数组总是存在多数元素。
>

> ```
> 输入: [3,2,3]
> 输出: 3
> ```

> 思路：
>
> 第一种：
>
> 我们使用哈希映射（HashMap）来存储每个元素以及出现的次数。对于哈希映射中的每个键值对，键表示一个元素，值表示该元素出现的次数。
>
> 我们用一个循环遍历数组 nums 并将数组中的每个元素加入哈希映射中。在这之后，我们遍历哈希映射中的所有键值对，返回值最大的键。我们同样也可以在遍历数组 nums 时候使用打擂台的方法，维护最大的值，这样省去了最后对哈希映射的遍历。
>
> 第二种：
>
> 排序，因为众数必定大于  `⌊ n/2 ⌋`， 所以在排序后，`nums[nums.size() >> 1] 的数必定是众数`

## [217. 存在重复元素](https://github.com/artintel/LeetCode/blob/master/217.%20%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/source_code.cpp)

> 给定一个整数数组，判断是否存在重复元素。
>
> 如果任意一值在数组中出现至少两次，函数返回 `true` 。如果数组中每个元素都不相同，则返回 `false` 。

> ```
> 输入: [1,2,3,1]
> 输出: true
> ```

## [219. 存在重复元素II](https://github.com/artintel/LeetCode/tree/master/219.%20%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%20II)

> 给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。
>

> ```
> 输入: nums = [1,2,3,1], k = 3
> 输出: true
> 
> 输入: nums = [1,0,1,1], k = 1
> 输出: true
> ```
>
> 利用 hash (unordered_set)

## [228. 汇总区间](https://github.com/artintel/LeetCode/blob/master/228.%20%E6%B1%87%E6%80%BB%E5%8C%BA%E9%97%B4/source_code.cpp)

> 给定一个无重复元素的有序整数数组 nums 。
>
> 返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表。也就是说，nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 x 。
>
> 列表中的每个区间范围 [a,b] 应该按如下格式输出：
>
> - "a->b" ，如果 a != b
> - "a" ，如果 a == b

> ```
> 输入：nums = [0,1,2,4,5,7]
> 输出：["0->2","4->5","7"]
> 解释：区间范围是：
> [0,2] --> "0->2"
> [4,5] --> "4->5"
> [7,7] --> "7"
> 
> 输入：nums = [0,2,3,4,6,8,9]
> 输出：["0","2->4","6","8->9"]
> 解释：区间范围是：
> [0,0] --> "0"
> [2,4] --> "2->4"
> [6,6] --> "6"
> [8,9] --> "8->9"
> 
> 输入：nums = []
> 输出：[]
> 
> 输入：nums = [0]
> 输出：["0"]
> ```
>
> 思路很简单，需要考虑的是是否越界，当 nums[i] 为大正整数， nums[i - 1] 为大的负整数时，如果使用 `nums[i] - nums[i - 1] == 1?` 作为条件边界的话，可能出现内存溢出的情况，所以使用 `nums[i - 1] + 1 == nums[i] ? ` 来作为条件边界

## [268. 丢失的数字](https://github.com/artintel/LeetCode/blob/master/268.%20%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/source_code.cpp)

> 给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。
>
> 进阶：
>
> 你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?
>

> ```
> 输入：nums = [3,0,1]
> 输出：2
> 解释：n = 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。
> 
> 输入：nums = [9,6,4,2,3,5,7,0,1]
> 输出：8
> 解释：n = 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。
> 
> 输入：nums = [0]
> 输出：1
> 解释：n = 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。
> ```
>
> 利用(a[0] + a[n]) * n / 2公式

## [283. 移动零](https://github.com/artintel/LeetCode/blob/master/283.%20%E7%A7%BB%E5%8A%A8%E9%9B%B6/source_code.cpp)

> 给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序

> ```
> 输入: [0,1,0,3,12]
> 输出: [1,3,12,0,0]
> ```
>
> 堆排序

## [414. 第三大的数](https://github.com/artintel/LeetCode/blob/master/414.%20%E7%AC%AC%E4%B8%89%E5%A4%A7%E7%9A%84%E6%95%B0/source_code.cpp)

> 给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。

> ```
> 输入: [3, 2, 1]
> 
> 输出: 1
> 
> 解释: 第三大的数是 1.
> 
> 输入: [1, 2]
> 
> 输出: 2
> 
> 解释: 第三大的数不存在, 所以返回最大的数 2 .
> 
> 输入: [2, 2, 3, 1]
> 
> 输出: 1
> 
> 解释: 注意，要求返回第三大的数，是指第三大且唯一出现的数。
> 存在两个值为2的数，它们都排第二。
> ```
>
> 1. 用了归并排序
> 2. 用了小顶堆

## [448. 找到所有数组中消失的数字](https://github.com/artintel/LeetCode/blob/master/448.%20%E6%89%BE%E5%88%B0%E6%89%80%E6%9C%89%E6%95%B0%E7%BB%84%E4%B8%AD%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/source_code.cpp)

> 给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。
>
> 找到所有在 [1, n] 范围之间没有出现在数组中的数字。
>
> 您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。
>

> ```
> 输入:
> [4,3,2,7,8,2,3,1]
> 
> 输出:
> [5,6]
> ```
>
> - 遍历输入数组的每个元素一次。
> - 我们将把 `|nums[i]|-1` 索引位置的元素标记为负数。即 `nums[|nums[i]| - 1] * -1` 。
> - 然后遍历数组，若当前数组元素 `nums[i]` 为负数，说明我们在数组中存在数字 `i+1`。
>
> 作者：LeetCode
> 链接：https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/solution/zhao-dao-suo-you-shu-zu-zhong-xiao-shi-de-shu-zi-2/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## [485. 最大连续1的个数](https://github.com/artintel/LeetCode/blob/master/485.%20%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/source_code.cpp)

> 给定一个二进制数组， 计算其中最大连续1的个数。

> ```
> 输入: [1,1,0,1,1,1]
> 输出: 3
> 解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3.
> ```
>
> 利用状态机来做。
>
> 根据当前数字的值，和当前状态进行判断。
>
> ```
> if elem == 1:
> 	如果当前状态是 true;
> 		temp_1 += 1;
> 	如果当前状态是 false;
> 		将当前状态改为 true;
> 		temp_1 += 1;
> if elem != 1:
> 	如果当前状态是 false;
> 		continue;
> 	如果当前状态时 true;
> 		max_1 = max(max_1, temp_1);
> 		将状态改为 false;
> ```

## [561. 数组拆分 I](https://github.com/artintel/LeetCode/blob/master/561.%20%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86%20I/source_code.cpp)

> 给定长度为 2n 的整数数组 nums ，你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), ..., (an, bn) ，使得从 1 到 n 的 min(ai, bi) 总和最大。
>
> 返回该 最大总和 。
>

> ```
> 输入：nums = [1,4,3,2]
> 输出：4
> 解释：所有可能的分法（忽略元素顺序）为：
> 1. (1, 4), (2, 3) -> min(1, 4) + min(2, 3) = 1 + 2 = 3
> 2. (1, 3), (2, 4) -> min(1, 3) + min(2, 4) = 1 + 2 = 3
> 3. (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4
> 所以最大总和为 4
> ```
>
> 排序：并且选取排序后每组的第一个数
>

## [566. 重塑矩阵](https://github.com/artintel/LeetCode/blob/master/566.%20%E9%87%8D%E5%A1%91%E7%9F%A9%E9%98%B5/source_code.cpp)

> 在MATLAB中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。
>
> 给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。
>
> 重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。
>
> 如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。

> ```
> 输入: 
> nums = 
> [[1,2],
>  [3,4]]
> r = 1, c = 4
> 输出: 
> [[1,2,3,4]]
> 解释:
> 行遍历nums的结果是 [1,2,3,4]。新的矩阵是 1 * 4 矩阵, 用之前的元素值一行一行填充新矩阵。
> ```
>

> 还是相对比较暴力的：将 `nums` 原数组数据遍历出来放在新的 `vector` 容器中，再通过一个双循环进行遍历进行`reshape` 操作

## [506. 斐波那契数列](https://github.com/artintel/LeetCode/blob/master/506.%20%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/source_code.cpp)

> **斐波那契数**，通常用 `F(n)` 表示，形成的序列称为**斐波那契数列**。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：

> ```
> F(0) = 0,   F(1) = 1
> F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
> ```

> 除开最常见的递归，参考邓俊辉老师的动态规划自底向上的方法：
>
> 因为递归会做很多重复的方式，通过两个变量动态地更新来找到所需要的 `fib(n)` 的值
>
> ```C++
> int f = 0, g = 1;
> while(--n){
> 	g = f + g;
> 	f = g - f;
> }
> return g;
> ```

## [面试题 01.01. 判定字符是否唯一](https://github.com/artintel/LeetCode/blob/master/%E9%9D%A2%E8%AF%95%E9%A2%98%2001.01.%20%E5%88%A4%E5%AE%9A%E5%AD%97%E7%AC%A6%E6%98%AF%E5%90%A6%E5%94%AF%E4%B8%80/source_code.cpp)

> 实现一个算法，确定一个字符串 `s` 的所有字符是否全都不同

> ```
> 输入: s = "leetcode"
> 输出: false 
> 
> 输入: s = "abc"
> 输出: true
> ```

> **限制：**
>
> - `0 <= len(s) <= 100`
> - 如果你不使用额外的数据结构，会很加分。

> 通过限制我们可以考虑使用位判定。字符总数为26个。那么定义一个 int 型足够。再通过左移和异或运算即可求得是否有重复

## [面试题 08.03. 魔术索引](https://github.com/artintel/LeetCode/blob/master/%E9%9D%A2%E8%AF%95%E9%A2%98%2008.03.%20%E9%AD%94%E6%9C%AF%E7%B4%A2%E5%BC%95/source_code.cpp)

> 魔术索引。 在数组A[0...n-1]中，有所谓的魔术索引，满足条件A[i] = i。给定一个有序整数数组，编写一种方法找出魔术索引，若有的话，在数组A中找出一个魔术索引，如果没有，则返回-1。若有多个魔术索引，返回索引值最小的一个。
>

> ```
>  输入：nums = [0, 2, 3, 4, 5]
>  输出：0
>  说明: 0下标的元素为0
> ```

> 用了暴力求解，线性扫描。但是在扫描过程中可以注意到:
>
> 数组是有序的， 那么当 `nums[i] < i` 的时候，在进行下一轮之前， 可以让 `i` 跳至 `nums[i]`, 即 `i = nums[i]`

## [面试题 01.02. 判定是否互为字符重排](https://github.com/artintel/LeetCode/blob/master/%E9%9D%A2%E8%AF%95%E9%A2%98%2001.02.%20%E5%88%A4%E5%AE%9A%E6%98%AF%E5%90%A6%E4%BA%92%E4%B8%BA%E5%AD%97%E7%AC%A6%E9%87%8D%E6%8E%92/source_code.cpp)

> 给定两个字符串 `s1` 和 `s2`，请编写一个程序，确定其中一个字符串的字符重新排列后，能否变成另一个字符串。

> ```
> 输入: s1 = "abc", s2 = "bca"
> 输出: true 
> 
> 输入: s1 = "abc", s2 = "bad"
> 输出: false
> ```

> 定义两个set,分别储存两个字符串中个字符出现的个数，最后再检查是否出现频率相等

## [605. 种花问题](https://github.com/artintel/LeetCode/blob/master/605.%20%E7%A7%8D%E8%8A%B1%E9%97%AE%E9%A2%98/source_code.cpp)

> 假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。
>
> 给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。
>

> ```
> 输入: flowerbed = [1,0,0,0,1], n = 1
> 输出: True
> 
> 输入: flowerbed = [1,0,0,0,1], n = 2
> 输出: False
> ```

> 考虑贪心算法+状态机，status 初始化为 true
>
> ```c++
> 判断当前位置是否为零：
>     if true & 状态机 false:
> 		状态机改为 true,表示下一个有可能能够种花
>     if true & 状态机 true & 下一个位置也为 0 :
> 		可以种花，status转为false;、
>         if i + 1 越界：
>             count++;
> 			break;
> 如果当前不为0，status == true:
> 	status = false;
> return count >= n ? true : false;
> ```
>

## [70. 爬楼梯](https://github.com/artintel/LeetCode/blob/master/70.%20%E7%88%AC%E6%A5%BC%E6%A2%AF/source_code.cpp)

> 假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。
>
> 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
>
> **注意：**给定 *n* 是一个正整数。

> ```
> 输入： 2
> 输出： 2
> 解释： 有两种方法可以爬到楼顶。
> 1.  1 阶 + 1 阶
> 2.  2 阶
> 
> 
> 输入： 3
> 输出： 3
> 解释： 有三种方法可以爬到楼顶。
> 1.  1 阶 + 1 阶 + 1 阶
> 2.  1 阶 + 2 阶
> 3.  2 阶 + 1 阶
> ```

> 动态规划，自底向上 爬楼梯和斐波那契数列是一样的题

## [198. 打家劫舍](https://github.com/artintel/LeetCode/blob/master/198.%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/source_code.cpp)

> 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
>
> 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。
>

> ```
> 输入：[1,2,3,1]
> 输出：4
> 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
>      偷窃到的最高金额 = 1 + 3 = 4 。
> 
> 输入：[2,7,9,3,1]
> 输出：12
> 解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
>      偷窃到的最高金额 = 2 + 9 + 1 = 12 。
> ```

> 动态规划遍历
>
> 对于当前的房屋，考虑 `dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])`
>
> 边界条件：
>
>  `dp[0] = nums[0], `
>
>  `dp[1] = max(nums[0], nums[1]);`

> 首先考虑最简单的情况。如果只有一间房屋，则偷窃该房屋，可以偷窃到最高总金额。如果只有两间房屋，则由于两间房屋相邻，不能同时偷窃，只能偷窃其中的一间房屋，因此选择其中金额较高的房屋进行偷窃，可以偷窃到最高总金额。
>
> 如果房屋数量大于两间，应该如何计算能够偷窃到的最高总金额呢？对于第 k(k>2) 间房屋，有两个选项：
>
> 偷窃第 k 间房屋，那么就不能偷窃第 k-1 间房屋，偷窃总金额为前 k−2 间房屋的最高总金额与第 k 间房屋的金额之和。
>
> 不偷窃第 k 间房屋，偷窃总金额为前 k-1 间房屋的最高总金额。
>
> 在两个选项中选择偷窃总金额较大的选项，该选项对应的偷窃总金额即为前 kk 间房屋能偷窃到的最高总金额。
>
> 用 dp[i] 表示前 i 间房屋能偷窃到的最高总金额，那么就有如下的状态转移方程：
>
> `dp[i] = max(dp[i-2]+nums[i], dp[i-1])`
>
> 
>
>
> 最终的答案即为 dp[n-1]，其中 n 是数组的长度。
>
> 作者：LeetCode-Solution
> 链接：https://leetcode-cn.com/problems/house-robber/solution/da-jia-jie-she-by-leetcode-solution/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## [303. 区域和检索 - 数组不可变](https://github.com/artintel/LeetCode/blob/master/303.%20%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E6%B5%8B%20-%20%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E5%8F%98/source_code.cpp)

> 给定一个整数数组  nums，求出数组从索引 i 到 j（i ≤ j）范围内元素的总和，包含 i、j 两点。
>
> 实现 NumArray 类：
>
> - `NumArray(int[] nums)` 使用数组 `nums` 初始化对象
> - `int sumRange(int i, int j)` 返回数组 `nums` 从索引 `i` 到 `j（i ≤ j）`范围内元素的总和，包含 `i、j `两点（也就是 `sum(nums[i], nums[i + 1], ... , nums[j])`）

> ```
> 输入： 2
> 输出： 2
> 解释： 有两种方法可以爬到楼顶。
> 1.  1 阶 + 1 阶
> 2.  2 阶
> 
> 
> 输入： 3
> 输出： 3
> 解释： 有三种方法可以爬到楼顶。
> 1.  1 阶 + 1 阶 + 1 阶
> 2.  1 阶 + 2 阶
> 3.  2 阶 + 1 阶
> ```

> 考虑hash，缓存，定义私有成员 `int* sum`, 在构造函数中 `new int [nums.size() + 1]` 数组来缓存 `0 - i`  的和，最终要求出 `i ~ j`  之间的数组和只需要 `return sum[j + 1] - sum[i]` 
>
> 对于为何要 `num.size() + 1` ，因为若是求 `0 ~ j`, 按`new int [num.size()]` 算的话，最终应该是 `return sum[j] - sum[i - 1];`, 越界报错。所以添加一个虚拟的 `0`

## [392. 判断子序列](https://github.com/artintel/LeetCode/blob/master/392.%20%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97/source_code.cpp)

> 给定字符串 s 和 t ，判断 s 是否为 t 的子序列。
>
> 你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 <=100）。
>
> 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。
>
> 示例 1:
> s = "abc", t = "ahbgdc"
>
> 返回 true.
>
> 示例 2:
> s = "axc", t = "ahbgdc"
>
> 返回 false.
>
> 后续挑战 :
>
> 如果有大量输入的 S，称作S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？
>

> `stack`保存`s`，倒序遍历 `t`,每当匹配，`stack.pop()`,最后判断 `stack.empty()?`，空即为子序列，反之不然

> DP动态规划：
>
> 可以将此题看错 最大公共子序列的变种 定义`dp[s.length() + 1][t.length() + 1]`
>
> for双重循环遍历数组
>
> 如果`s[i] == t[j], dp[i][j] = dp[i - 1][j - 1];`
>
> 否则`dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]);`

## [628. 三个数的最大乘积](https://github.com/artintel/LeetCode/blob/master/628.%20%E4%B8%89%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/source_code.cpp)

> 给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。

> ```
> 输入: [1,2,3]
> 输出: 6
> ```

## [643. 子数组最大平均数](https://github.com/artintel/LeetCode/blob/master/643.%20%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E6%95%B0/source_code.cpp)

> 给定 `n` 个整数，找出平均数最大且长度为 `k` 的连续子数组，并输出该最大平均数。

> ```
> 输入: [1,12,-5,-6,50,3], k = 4
> 输出: 12.75
> 解释: 最大平均数 (12-5-6+50)/4 = 51/4 = 12.75
> ```

> 滑动窗口，k 大小的窗口数组在`nums()`数组上滑动，找到和最大窗口

## [10. 正则表达式匹配](https://github.com/artintel/LeetCode/blob/master/10.%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/source_code.cpp)

> 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。
>
> - '.' 匹配任意单个字符
>
> - '*' 匹配零个或多个前面的那一个元素
>
> 所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。

> ```
> 输入：s = "aa" p = "a"
> 输出：false
> 解释："a" 无法匹配 "aa" 整个字符串。
> 
> 
> 输入：s = "aa" p = "a*"
> 输出：true
> 解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
> 
> 
> 输入：s = "ab" p = ".*"
> 输出：true
> 解释：".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
> 
> 输入：s = "aab" p = "c*a*b"
> 输出：true
> 解释：因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。
> 
> ```

> 动态规划的思想，注意状态的更换

## [661. 图片平滑器](https://github.com/artintel/LeetCode/blob/master/661.%20%E5%9B%BE%E7%89%87%E5%B9%B3%E6%BB%91%E5%99%A8/source_code.cpp)

> 包含整数的二维矩阵 M 表示一个图片的灰度。你需要设计一个平滑器来让每一个单元的灰度成为平均灰度 (向下舍入) ，平均灰度的计算是周围的8个单元和它本身的值求平均，如果周围的单元格不足八个，则尽可能多的利用它们。
>

> ```
> 输入:
> [[1,1,1],
>  [1,0,1],
>  [1,1,1]]
> 输出:
> [[0, 0, 0],
>  [0, 0, 0],
>  [0, 0, 0]]
> 解释:
> 对于点 (0,0), (0,2), (2,0), (2,2): 平均(3/4) = 平均(0.75) = 0
> 对于点 (0,1), (1,0), (1,2), (2,1): 平均(5/6) = 平均(0.83333333) = 0
> 对于点 (1,1): 平均(8/9) = 平均(0.88888889) = 0
> ```

> 类似深度学习神经网络里的 kernel

## [11. 盛最多水的容器](https://github.com/artintel/LeetCode/blob/master/11.%20%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/source_code.cpp)

> 给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
>

> ```
> 输入：[1,8,6,2,5,4,8,3,7]
> 输出：49 
> 在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
> ```

> 双指针法：

## [15. 三数之和](https://github.com/artintel/LeetCode/blob/master/15.%20%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/source_code.cpp)

> 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。
>
> 注意：答案中不可以包含重复的三元组。
>

> ```
> 给定数组 nums = [-1, 0, 1, 2, -1, -4]，
> 
> 满足要求的三元组集合为：
> [
>   [-1, 0, 1],
>   [-1, -1, 2]
> ]
> ```

> 排序以及双指针

## [16. 最接近的三数之和](https://github.com/artintel/LeetCode/blob/master/16.%20%E6%9C%80%E6%8E%A5%E8%BF%91%E7%9A%84%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/source_code.cpp)

> 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。
>

> ```
> 输入：nums = [-1,2,1,-4], target = 1
> 输出：2
> 解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。
> ```

> 本题思想与15.三数之和基本一致。
>
> 我们利用`first & third`  指针分别指向排序后的数组头尾，进行 `for-loop`
>
> `for(int first = 0; first < nums.size(); first++)`
>
> `for(int third = nums.size() - 1; third > first + 1; third--)`
>
> 需注意的是，当他们开始移动要注意以后的的值和上一路的值是否相等 --- 即避免重复
>
> `if(first > 0 && nums[first - 1] == nums[first]) continue;`
>
> `if(third != nums.size() - 1 && nums[third + 1] == nums[third]) continue;`
>
> 于此，再利用一个移动指针 `second = first + 1`, 在 `while(second < third)` 的边界条件下查看三数之和与 `target` 的差距, 并和上一次的的差值比大小，去最小值，并用中间变量`result` 存储.
>
> 最后返回 `target - result` 即可

## [31. 下一个排列](https://github.com/artintel/LeetCode/blob/master/31.%20%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/source_code.cpp)

> 实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。
>
> 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。
>
> 必须 原地 修改，只允许使用额外常数空间。
>

> ```
> 输入：nums = [1,2,3]
> 输出：[1,3,2]
> 
> 输入：nums = [3,2,1]
> 输出：[1,2,3]
> 
> 输入：nums = [1,1,5]
> 输出：[1,5,1]
> 
> 输入：nums = [1]
> 输出：[1]
> ```

> 本题要求我们实现一个算法，将给定数字序列重新排列成字典序中下一个更大的排列。
>
> 以数字序列 [1,2,3] 为例，其排列按照字典序依次为：
> [1,2,3]
> [1,3,2]
> [2,1,3]
> [2,3,1]
> [3,1,2]
> [3,2,1]
>
> 这样，排列 [2,3,1] 的下一个排列即为 [3,1,2]。特别的，最大的排列 [3,2,1] 的下一个排列为最小的排列 [1,2,3]。
>
> 思路及解法
>
> 注意到下一个排列总是比当前排列要大，除非该排列已经是最大的排列。我们希望找到一种方法，能够找到一个大于当前序列的新序列，且变大的幅度尽可能小。具体地：
>
> 1. 我们需要将一个左边的「较小数」与一个右边的「较大数」交换，以能够让当前排列变大，从而得到下一个排列。
>
> 2. 同时我们要让这个「较小数」尽量靠右，而「较大数」尽可能小。当交换完成后，「较大数」右边的数需要按照升序重新排列。这样可以在保证新排列大于原来排列的情况下，使变大的幅度尽可能小。
>
> 以排列 [4,5,2,6,3,1] 为例：
>
> 1. 我们能找到的符合条件的一对「较小数」与「较大数」的组合为 2 与 3，满足「较小数」尽量靠右，而「较大数」尽可能小。
>
> 2. 当我们完成交换后排列变为 [4,5,3,6,2,1] ，此时我们可以重排「较小数」右边的序列，序列变为 [4,5,3,1,2,6] 。
>
> 具体地，我们这样描述该算法，对于长度为 nn 的排列 aa：
>
> 1. 首先从后向前查找第一个顺序对 `(i, i+1)`，满足` a[i] < a[i+1]`。这样「较小数」即为 `a[i]`。此时 `[i+1,n)` 必然是下降序列。
>
> 2. 如果找到了顺序对，那么在区间 `[i+1,n)` 中从后向前查找第一个元素 j 满足 `a[i] < a[j]`。这样「较大数」即为 `a[j]`。
>
> 3. 交换 `a[i]` 与 `a[j]`，此时可以证明区间 `[i+1,n)` 必为降序。我们可以直接使用双指针反转区间 `[i+1,n)` 使其变为升序，而无需对该区间进行排序。
>
> `reverse(begin, end);`
>
> 作者：LeetCode-Solution
> 链接：https://leetcode-cn.com/problems/next-permutation/solution/xia-yi-ge-pai-lie-by-leetcode-solution/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## [32. 最长有效括号](https://github.com/artintel/LeetCode/blob/master/32.%20%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/source_code.cpp)

> 给定一个只包含 `'('` 和 `')'` 的字符串，找出最长的包含有效括号的子串的长度。

> ```
> 输入: "(()"
> 输出: 2
> 解释: 最长有效括号子串为 "()"
> 
> 输入: ")()())"
> 输出: 4
> 解释: 最长有效括号子串为 "()()"
> ```

> 解法1：暴力解法，理解成设置一个移动的窗口，窗口大小为偶数，最开始的窗口大小根据 s 的长度设定，取最长。判断窗口内的括号集合是否为可匹配括号集，如果匹配则返回窗口长度，且为当前最大。如果不匹配则继续遍历，或者减小窗口长度。
>
> 注：该解法会超时
>
> 解法2：DP动态规划
>
> 思路和算法
>
> 我们定义 `dp[i] `表示以下标 `i` 字符结尾的最长有效括号的长度。我们将 `dp` 数组全部初始化为 `0` 。显然有效的子串一定以 `‘)’ `结尾，因此我们可以知道以 `‘(’` 结尾的子串对应的 `dp` 值必定为 `0` ，我们只需要求解 `‘)’ `在 `dp` 数组中对应位置的值。
>
> 我们从前往后遍历字符串求解 `dp` 值，我们每两个字符检查一次：
>
> 1. `s[i] = ‘)’` 且 `s[i − 1]=‘(’`，也就是字符串形如 `“……()”`，我们可以推出：
>
>    ​												`dp[i]=dp[i-2]+2`
>
>    我们可以进行这样的转移，是因为结束部分的 `"()"` 是一个有效子字符串，并且将之前有效子字符串的长度增加了 `2` 。
>
> 2. `s[i]=‘)’` 且 `s[i−1]=‘)’`，也就是字符串形如 `“……))”`，我们可以推出：
>    如果`s[i−dp[i−1]−1]=‘(’`，那么
>
>    ​									`dp[i]=dp[i−1]+dp[i−dp[i−1]−2]+2`
>
> 我们考虑如果倒数第二个` ‘)’ `是一个有效子字符串的一部分（ 记作 `sub_s` ），对于最后一个 `‘)’ `，如果它是一个更长子字符串的一部分，那么它一定有一个对应的` ‘(’ `，且它的位置在倒数第二个 `‘)’` 所在的有效子字符串的前面（也就是 `sub_s` 的前面）。因此，如果子字符串 `sub_s` 的前面恰好是 `‘(’` ，那么我们就用 2 加上` sub_s` 的长度`（dp[i−1]）`去更新 `dp[i]`。同时，我们也会把有效子串 `“(sub_s)”`之前的有效子串的长度也加上，也就是再加上 `dp[i−dp[i−1]−2]`。
>
> 最后的答案即为 `dp` 数组中的最大值。
>
> 作者：LeetCode-Solution
> 链接：https://leetcode-cn.com/problems/longest-valid-parentheses/solution/zui-chang-you-xiao-gua-hao-by-leetcode-solution/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
>
> 栈:
>
> 撇开动态规划方法，大多数人对于这题的第一直觉是找到每个可能的子串后判断它的有效性，但这样的时间复杂度会达到 O(n^3)，无法通过所有测试用例。但是通过栈，我们可以在遍历给定字符串的过程中去判断到目前为止扫描的子串的有效性，同时能得到最长有效括号的长度。
>
> 具体做法是我们始终保持栈底元素为当前已经遍历过的元素中「最后一个没有被匹配的右括号的下标」，这样的做法主要是考虑了边界条件的处理，栈里其他元素维护左括号的下标：
>
> 对于遇到的每个 `‘(’` ，我们将它的下标放入栈中
> 对于遇到的每个 `‘)’` ，我们先弹出栈顶元素表示匹配了当前右括号：
> 如果栈为空，说明当前的右括号为没有被匹配的右括号，我们将其下标放入栈中来更新我们之前提到的「最后一个没有被匹配的右括号的下标」
> 如果栈不为空，当前右括号的下标减去栈顶元素即为「以该右括号为结尾的最长有效括号的长度」
> 我们从前往后遍历字符串并更新答案即可。
>
> 需要注意的是，如果一开始栈为空，第一个字符为左括号的时候我们会将其放入栈中，这样就不满足提及的「最后一个没有被匹配的右括号的下标」，为了保持统一，我们在一开始的时候往栈中放入一个值为 `-1` 的元素。
>
> 作者：LeetCode-Solution
> 链接：https://leetcode-cn.com/problems/longest-valid-parentheses/solution/zui-chang-you-xiao-gua-hao-by-leetcode-solution/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## [33. 搜索旋转排序数组](https://github.com/artintel/LeetCode/blob/master/33.%20%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/source_code.cpp)

> 给你一个整数数组 nums ，和一个整数 target 。
>
> 该整数数组原本是按升序排列，但输入时在预先未知的某个点上进行了旋转。（例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] ）。
>
> 请你在数组中搜索 target ，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。
>

> ```
> 输入：nums = [4,5,6,7,0,1,2], target = 0
> 输出：4
> 
> 输入：nums = [4,5,6,7,0,1,2], target = 3
> 输出：-1
> 
> 输入：nums = [1], target = 0
> 输出：-1
> ```

> 二分搜索
>
> 思路和算法
>
> 题目要求算法时间复杂度必须是 `O(logn)` 的级别，这提示我们可以使用二分搜索的方法。
>
> 但是数组本身不是有序的，进行旋转后只保证了数组的局部是有序的，这还能进行二分搜索吗？答案是可以的。
>
> 可以发现的是，我们将数组从中间分开成左右两部分的时候，一定有一部分的数组是有序的。拿示例来看，我们从 6 这个位置分开以后数组变成了 [4, 5, 6] 和 [7, 0, 1, 2] 两个部分，其中左边 [4, 5, 6] 这个部分的数组是有序的，其他也是如此。
>
> 这启示我们可以在常规二分搜索的时候查看当前 mid 为分割位置分割出来的两个部分 `[l, mid]` 和 `[mid + 1, r]` 哪个部分是有序的，并根据有序的那个部分确定我们该如何改变二分搜索的上下界，因为我们能够根据有序的那部分判断出 `target` 在不在这个部分：
>
> 如果 `[l, mid - 1`] 是有序数组，且` target` 的大小满足 `[nums[l], nums[mid])`，则我们应该将搜索范围缩小至 `[l, mid - 1]`，否则在` [mid + 1, r]` 中寻找。
> 如果` [mid, r]` 是有序数组，且 `target` 的大小满足 `(nums[mid + 1],nums[r]]`，则我们应该将搜索范围缩小至 `[mid + 1, r]`，否则在 `[l, mid - 1]` 中寻找。
>
> 作者：LeetCode-Solution
> 链接：https://leetcode-cn.com/problems/search-in-rotated-sorted-array/solution/sou-suo-xuan-zhuan-pai-xu-shu-zu-by-leetcode-solut/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## [34. 在排序数组中查找元素的第一个和最后一个位置](https://github.com/artintel/LeetCode/blob/master/34.%20%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/source_code.cpp)

> 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
>
> 如果数组中不存在目标值 target，返回 [-1, -1]。
>
> 进阶：
>
> 你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？
>

> ```
> 输入：nums = [5,7,7,8,8,10], target = 8
> 输出：[3,4]
> 
> 输入：nums = [5,7,7,8,8,10], target = 6
> 输出：[-1,-1]
> 
> 输入：nums = [], target = 0
> 输出：[-1,-1]
> ```

> 二分搜索
>
> 思路和算法
>
> 题目要求算法时间复杂度必须是 `O(logn)` 的级别，这提示我们可以使用二分搜索的方法。
>
> 数组本身值有序的，使用二分查找 `nums[i] == target`, 为真返回 `i` 否则返回 `-1`, 且如当确定不为真时，可直接返回 `[-1, -1]`， 否则，进行查找 `nums[i] == target` 下的最大坐标值并返回。需要考虑的边界条件
>
> - nums.size() == 0
> - nums.size() == 1
> - 对于查找最小时 `return nums[left] == target ? left : -1;`
> - 对于查找最大时 `return nums[left] == target ? left : left - 1;`

## [41. 缺失的第一个正数](https://github.com/artintel/LeetCode/blob/master/41.%20%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/source_code.cpp)

> 给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。

> ```
> 输入: [1,2,0]
> 输出: 3
> 
> 输入: [3,4,-1,1]
> 输出: 2
> 
> 输入: [7,8,9,11,12]
> 输出: 1
> ```

> 哈希:
>
> 另建立一个 `vector<int> ans(nums.size(), 0);`
>
> 边界条件：当 `nums[i]` 处于 `[1, nums.size]` 之间，那么 `ans[elem - 1] = 1`，最后遍历 `ans` 当遇到第一个 `ans[i] != 1` 那么就找到了所缺的最小正整数
>
> ```C++
> for(auto elem : nums){
> 	if(elem <= n && elem > 0){
> 	ans[elem - 1] = -1;
> 	}
> }        
> for(int i = 0; i < n; i++){
>     if(ans[i] != -1)
>         return i + 1;
> }
> return n + 1;
> ```
>
> 如果最终 `ans` 的值全为 `1`， 那么所缺最小值即为 `nums.size() + 1`
>

## [42. 接雨水](https://github.com/artintel/LeetCode/blob/master/42.%20%E6%8E%A5%E9%9B%A8%E6%B0%B4/source_code.cpp)

> 给定 *n* 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

> ```
> 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
> 输出：6
> 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水
> 
> 输入：height = [4,2,0,3,2,5]
> 输出：9
> ```

> **动态规划**
>
> 对于数组中的每个元素，我们找出下雨后水能达到的最高位置，等于两边最大高度的较小值减去当前高度的值。
>
> 可以提前存储这个值。因此，可以通过动态编程解决。
>
> **算法**
>
> 找到数组中从下标 i 到最左端最高的条形块高度 left_max。
> 找到数组中从下标 i 到最右端最高的条形块高度 \right_max。
> 扫描数组 height 并更新答案：
> 累加 min(max_left[i],max_right[i])−height[i] 到 ans 上
>
> 作者：LeetCode
> 链接：https://leetcode-cn.com/problems/trapping-rain-water/solution/jie-yu-shui-by-leetcode/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
>
> **双指针**
>
> **算法**
>
> - 初始化 left 指针为 0 并且 right 指针为 size-1
> - While left<right, do:
>   - **If** height[left] < height[right]
>     - **If** height[left]≥left_max, 更新 left_max
>     - **Else** 累加 left_max−height[left] 到 ans
>     - left = left + 1.
>   - **Else**
>     - **If** height[right] ≥ right_max, 更新 right_max
>     - **Else** 累加 right_max−height[right] 到 ans
>     - right = right - 1.
>
> 作者：LeetCode
> 链接：https://leetcode-cn.com/problems/trapping-rain-water/solution/jie-yu-shui-by-leetcode/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## [44. 通配符匹配](https://github.com/artintel/LeetCode/blob/master/44.%20%E9%80%9A%E9%85%8D%E7%AC%A6%E5%8C%B9%E9%85%8D/source_code.cpp)

> 给定一个字符串 (`s`) 和一个字符模式 (`p`) ，实现一个支持 `'?'` 和 `'*'` 的通配符匹配。

> ```
> '?' 可以匹配任何单个字符。
> '*' 可以匹配任意字符串（包括空字符串）。
> ```

> 两个字符串**完全匹配**才算匹配成功。
>
> **说明:**
>
> - `s` 可能为空，且只包含从 `a-z` 的小写字母。
> - `p` 可能为空，且只包含从 `a-z` 的小写字母，以及字符 `?` 和 `*`。
>
> ```
> 输入:
> s = "aa"
> p = "a"
> 输出: false
> 解释: "a" 无法匹配 "aa" 整个字符串。
> 
> 输入:
> s = "aa"
> p = "*"
> 输出: true
> 解释: '*' 可以匹配任意字符串。
> 
> 输入:
> s = "cb"
> p = "?a"
> 输出: false
> 解释: '?' 可以匹配 'c', 但第二个 'a' 无法匹配 'b'。
> 
> 输入:
> s = "adceb"
> p = "*a*b"
> 输出: true
> 解释: 第一个 '*' 可以匹配空字符串, 第二个 '*' 可以匹配字符串 "dce".
> 
> 输入:
> s = "acdcb"
> p = "a*c?b"
> 输出: false
> ```
>
> 本题和之前的如 “正则化匹配” 略有不同，此处的 `*` 匹配的是所有字符串
>
> 动态规划思想
>
> - `dp[s.size() + 1][p.size() + 1]`
>
> - `dp[0][0] = 0`
>
> - 进行遍历，并储存之前的状态
>
> - `if(i == 0 && p[j - 1] == '*')`
>
>   - 此处假设的是空字符串，`*` 的状态应该与 `dp[0][j - 1]` 相同。因为是空字符串，空字符串已经匹配了一个空字符串。所以要匹配 `*` ，`*` 之前必须没有其他的字符串才能匹配空字符串。因为空字符串已经没有其他的字符或者字符串来和 `*` 之前的非空字符串匹配(这是反过来的思考)
>
> - `else if (p[j - 1] == '*')` 此时已经度过 `i == 0` 的情况，
>
>   - ```
>     dp[i][j] = dp[i - 1][j] | dp[i][j];
>     dp[i][j] = dp[i][j - 1] | dp[i][j];
>     ```
>
> - `else` 如果单个匹配成功则： `dp[i][j] = dp[i - 1][j - 1];` 

## [45. 跳跃游戏II](https://github.com/artintel/LeetCode/blob/master/45.%20%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F%20II/source_code.cpp)

> 给定一个非负整数数组，你最初位于数组的第一个位置。
>
> 数组中的每个元素代表你在该位置可以跳跃的最大长度。
>
> 你的目标是使用最少的跳跃次数到达数组的最后一个位置。
>

> ```
> 输入: [2,3,1,1,4]
> 输出: 2
> 解释: 跳到最后一个位置的最小跳跃数是 2。
>      从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
> ```

> 如果我们「贪心」地进行正向查找，每次找到可到达的最远位置，就可以在线性时间内得到最少的跳跃次数。
>
> 例如，对于数组 [2,3,1,2,4,2,3]，初始位置是下标 0，从下标 0 出发，最远可到达下标 2。下标 0 可到达的位置中，下标 1 的值是 3，从下标 1 出发可以达到更远的位置，因此第一步到达下标 1。
>
> 从下标 1 出发，最远可到达下标 4。下标 1 可到达的位置中，下标 4 的值是 4 ，从下标 4 出发可以达到更远的位置，因此第二步到达下标 4。
>
> 在具体的实现中，我们维护当前能够到达的最大下标位置，记为边界。我们从左到右遍历数组，到达边界时，更新边界并将跳跃次数增加 1。
>
> 在遍历数组时，我们不访问最后一个元素，这是因为在访问最后一个元素之前，我们的边界一定大于等于最后一个位置，否则就无法跳到最后一个位置了。如果访问最后一个元素，在边界正好为最后一个位置的情况下，我们会增加一次「不必要的跳跃次数」，因此我们不必访问最后一个元素。
>
> 作者：LeetCode-Solution
> 链接：https://leetcode-cn.com/problems/jump-game-ii/solution/tiao-yue-you-xi-ii-by-leetcode-solution/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## [54. 螺旋矩阵](https://github.com/artintel/LeetCode/blob/master/54.%20%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/source_code.cpp)

> 给定一个包含 *m* x *n* 个元素的矩阵（*m* 行, *n* 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。

> ```
> 输入:
> [
>  [ 1, 2, 3 ],
>  [ 4, 5, 6 ],
>  [ 7, 8, 9 ]
> ]
> 输出: [1,2,3,6,9,8,7,4,5]
> ```

>
> 暴力解法: 每一次行列经过元素个数是递减至0的，通过此规律来引导对元素的遍历。

## [48. 旋转图像](https://github.com/artintel/LeetCode/tree/master/48.%20%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F)

> 给定一个 n × n 的二维矩阵表示一个图像。
>
> 将图像顺时针旋转 90 度。
>
> 说明：
>
> 你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像
>

> ```
> 给定 matrix = 
> [
>   [1,2,3],
>   [4,5,6],
>   [7,8,9]
> ],
> 
> 原地旋转输入矩阵，使其变为:
> [
>   [7,4,1],
>   [8,5,2],
>   [9,6,3]
> ]
> ```

>暴力解法: 将矩阵看作了一圈一圈的数组
>
>每个数的移动规律如下：
>
>```
>    void rotate_outline(vector<vector<int>>& matrix, int end, int first){
>        int index = first;
>        int gap = end - first - 1;
>        for(; index < end; index++){
>            swap(matrix[first][index], matrix[index][end]);
>            swap(matrix[first][index], matrix[end][end - index + first]);
>            swap(matrix[first][index], matrix[end - index + first][first]);
>        }  
>    }
>```

## [55. 跳跃游戏](https://github.com/artintel/LeetCode/blob/master/55.%20%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/source_code.cpp)

> 给定一个非负整数数组，你最初位于数组的第一个位置。
>
> 数组中的每个元素代表你在该位置可以跳跃的最大长度。
>
> 判断你是否能够到达最后一个位置。

> ```
> 输入: [2,3,1,1,4]
> 输出: true
> 解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。
> 
> 输入: [3,2,1,0,4]
> 输出: false
> 解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。
> ```

>贪心算法：
>
>定义一个 `end_of_position` 作为当前序列能到达的最大位置，并从 `[0, end_of_position)` 遍历，如果有值大于 `end_of_position`，更新最大位置，当最大位置 `>= lenght - 1` 时，既能到达数组最后位置，反之则不能

## [56. 合并区间](https://github.com/artintel/LeetCode/blob/master/56.%20%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/source_code.cpp)

> 给出一个区间的集合，请合并所有重叠的区间。

> ```
> 输入: intervals = [[1,3],[2,6],[8,10],[15,18]]
> 输出: [[1,6],[8,10],[15,18]]
> 解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
> 
> 输入: intervals = [[1,4],[4,5]]
> 输出: [[1,5]]
> 解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。
> ```

>官方开头用了排序。(早说啊。。。。。。。)

## [922. 按奇偶排序数组 II](https://github.com/artintel/LeetCode/blob/master/922.%20%E6%8C%89%E5%A5%87%E5%81%B6%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%84%20II/source_code.cpp)

> 给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。
>
> 对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。
>
> 你可以返回任何满足上述条件的数组作为答案。
>

> ```
> 输入：[4,2,5,7]
> 输出：[4,5,2,7]
> 解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。
> 
> 提示：
> 
> 2 <= A.length <= 20000
> A.length % 2 == 0
> 0 <= A[i] <= 1000
> ```

>奇偶个数各一半，双指针思想，分别从 `i == 0` 和 `j == n - 1` 开始，并且每次移动步长间隔为 `2`；
>
>```
>if A[i] % 2 != 0 & A[j] % 2 != 1: swap(A[i], A[j])
>if A[i] % 2 == 0: i += 2
>if A[j] % 2 == 1: j += 2
>```

## [896. 单调数列](https://github.com/artintel/LeetCode/blob/master/896.%20%E5%8D%95%E8%B0%83%E6%95%B0%E5%88%97/source_code.cpp)

> 如果数组是单调递增或单调递减的，那么它是单调的。
>
> 如果对于所有 i <= j，A[i] <= A[j]，那么数组 A 是单调递增的。 如果对于所有 i <= j，A[i]> = A[j]，那么数组 A 是单调递减的。
>
> 当给定的数组 A 是单调数组时返回 true，否则返回 false。
>

## [57. 插入区间](https://github.com/artintel/LeetCode/blob/master/57.%20%E6%8F%92%E5%85%A5%E5%8C%BA%E9%97%B4/source_code.cpp)

> 给出一个*无重叠的 ，*按照区间起始端点排序的区间列表。
>
> 在列表中插入一个新的区间，你需要确保列表中的区间仍然有序且不重叠（如果有必要的话，可以合并区间）。
>
> ```
> 输入：intervals = [[1,3],[6,9]], newInterval = [2,5]
> 输出：[[1,5],[6,9]]
> 
> 输入：intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
> 输出：[[1,2],[3,10],[12,16]]
> 解释：这是因为新的区间 [4,8] 与 [3,5],[6,7],[8,10] 重叠。
> ```

> 稍显暴力：直接插入到区间列表中，`sort()`排序，再通过合并区间算法返回所需值 -- 增加了时间复杂度
>
> 可查看官方代码。

## [59. 螺旋矩阵](https://github.com/artintel/LeetCode/blob/master/59.%20%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II/source_code.cpp)

> 给定一个正整数 *n*，生成一个包含 1 到 *n*2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。
>
> ```
> 输入: 3
> 输出:
> [
>  [ 1, 2, 3 ],
>  [ 8, 9, 4 ],
>  [ 7, 6, 5 ]
> ]
> ```

> 定义边界条件， left, right, up, down;
>
> 以及 var <= n*n;
>
> ```C++
>             for(int i = left; i <= right; i++) matrix[up][i] = var++;
>             up++;
>             for(int i = up; i <= down; i++) matrix[i][right] = var++;
>             right--;
>             for(int i = right; i >= left; i--) matrix[down][i] = var++;
>             down--;
>             for(int i = down; i >= up; i--) matrix[i][left] = var++;
>             left++;
> ```
>

## [29. 两数相除](https://github.com/artintel/LeetCode/blob/master/29.%20%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4/source_code.cpp)

> 给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。
>
> 返回被除数 dividend 除以除数 divisor 得到的商。
>
> 整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2
>
> ```
> 输入: dividend = 10, divisor = 3
> 输出: 3
> 解释: 10/3 = truncate(3.33333..) = truncate(3) = 3
> 
> 输入: dividend = 7, divisor = -3
> 输出: -2
> 解释: 7/-3 = truncate(-2.33333..) = -2
> ```

> 提示：
>
> - 被除数和除数均为 32 位有符号整数。
> - 除数不为 0。
> - 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−2^31,  2^31 − 1]。本题中，如果除法结果溢出，则返回 2^31 − 1。
>
> 举个例子：11 除以 3 。
> 首先11比3大，结果至少是1， 然后我让3翻倍，就是6，发现11比3翻倍后还要大，那么结果就至少是2了，那我让这个6再翻倍，得12，11不比12大，吓死我了，差点让就让刚才的最小解2也翻倍得到4了。但是我知道最终结果肯定在2和4之间。也就是说2再加上某个数，这个数是多少呢？我让11减去刚才最后一次的结果6，剩下5，我们计算5是3的几倍，也就是除法，看，递归出现了。说得很乱，不严谨，大家看个大概，然后自己在纸上画一画，或者直接看我代码就好啦！
>
> 作者：liujin-4
> 链接：https://leetcode-cn.com/problems/divide-two-integers/solution/po-su-de-xiang-fa-mei-you-wei-yun-suan-mei-you-yi-/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## [50. Pow(x, n)](https://github.com/artintel/LeetCode/blob/master/50.%20Pow(x%2C%20n)/source_code.cpp)

> 实现 [pow(*x*, *n*)](https://www.cplusplus.com/reference/valarray/pow/) ，即计算 x 的 n 次幂函数。
>
> ```
> 示例 1:
> 
> 输入: 2.00000, 10
> 输出: 1024.00000
> 示例 2:
> 
> 输入: 2.10000, 3
> 输出: 9.26100
> 示例 3:
> 
> 输入: 2.00000, -2
> 输出: 0.25000
> 解释: 2-2 = 1/22 = 1/4 = 0.25
> ```

> **说明:**
>
> - -100.0 < *x* < 100.0
> - *n* 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。
>
> 解题的重点在于边界条件是否越界。和 幂的正负性 。
>
> ```C++
>     double pow(double x, int n){
>         if(n == 1) return x;
>         if(n == -1) return 1 / x;
>         if(n > 0){
>             if( n % 2 == 1) return x * pow(x, n - 1);
>             else return pow(x * x, n / 2);
>         }
>         else {
>             if(n % 2 == -1) {
>                 n += 1;
>                 n = -n;
>                 return 1 / (x * pow(x, n));
>             }
>             else {
>                 n /= 2;
>                 n = -n;
>                 return 1 / (pow(x * x, n));
>             }
>         }
>     }
> ```
>

## [69. x的平方根](https://github.com/artintel/LeetCode/blob/master/69.%20x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/source_code.cpp)

> 计算并返回 *x* 的平方根，其中 *x* 是非负整数。
>
> 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。
>
> ```
> 输入: 4
> 输出: 2
> 
> 输入: 8
> 输出: 2
> 说明: 8 的平方根是 2.82842..., 
> 由于返回类型是整数，小数部分将被舍去。
> ```

> 通过二分查找法找到对应数值

## [74. 搜索二维矩阵](https://github.com/artintel/LeetCode/blob/master/74.%20%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/source_code.cpp)

> 编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性：
>
> 每行中的整数从左到右按升序排列。
> 每行的第一个整数大于前一行的最后一个整数。
>
> ```
> 输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,50]], target = 3
> 输出：true
> ```

> 由题，我们可知，当二维矩阵按行排列拉通时，是一个升序排列的数组或向量。那么我们可以采用二分查找法对这个“一维向量”进行查找。正常的二分查找模板即可。其中，需要注意的是 二维 和 一维 之间的坐标如何转换。转换如下：
>
> ```
> vector<int> a[index] = vector<vector<int>> A[index / weight][index % weight]
> ```
>

## [81. 搜索旋转排序数组 II](https://github.com/artintel/LeetCode/blob/master/81.%20%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%20II/source_code.cpp)

> 假设按照升序排序的数组在预先未知的某个点上进行了旋转。
>
> ( 例如，数组 [0,0,1,2,2,5,6] 可能变为 [2,5,6,0,0,1,2] )。
>
> 编写一个函数来判断给定的目标值是否存在于数组中。若存在返回 true，否则返回 false。
>
> ```
> 输入: nums = [2,5,6,0,0,1,2], target = 0
> 输出: true
> 
> 输入: nums = [2,5,6,0,0,1,2], target = 3
> 输出: false
> ```

> 解题思路：
> 本题是需要使用二分查找，怎么分是关键，举个例子：
>
> - 第一类
>   10111 和 11101 这种。此种情况下 `nums[start] == nums[mid]`，分不清到底是前面有序还是后面有序，此时 `start++` 即可。相当于去掉一个重复的干扰项。
> - 第二类
>   2 3 4 5 6 7 1 这种，也就是 `nums[start] < nums[mid]`。此例子中就是 2 < 5；
>   这种情况下，前半部分有序。因此如果 `nums[start] <= target < nums[mid]`，则在前半部分找，否则去后半部分找。
> - 第三类
>   6 7 1 2 3 4 5 这种，也就是 `nums[start] > nums[mid]`。此例子中就是 6 > 2；
>   这种情况下，后半部分有序。因此如果 `nums[mid] < target <= nums[end]`。则在后半部分找，否则去前半部分找。
>
> 作者：reedfan
> 链接：https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/solution/zai-javazhong-ji-bai-liao-100de-yong-hu-by-reedfan/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## [剑指 Offer 12. 矩阵中的路径](https://github.com/artintel/LeetCode/blob/master/%E5%89%91%E6%8C%87%20Offer%2012.%20%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/source_code.cpp)

> 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。
>
> [["a","**b**","c","e"],
> ["s","**f**","**c**","s"],
> ["a","d","**e**","e"]]
>
> 但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。
>
> ```
> 输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
> 输出：true
> 
> 输入：board = [["a","b"],["c","d"]], word = "abcd"
> 输出：false
> ```

> 此类题属于“回溯”的算法，应当考虑 “递归 + bfs” 的方法，需要注意的点是：
>
> - 一个和矩阵匹配的布尔向量 [row * cols + col]，用于记录对应位置是否属于所找路径
> - Length 用于记录是否找全，边界条件 `word[Length] == '\0'`, 另外，Length 从 0 开始，若找到路径当前对应的位置或字符， Length++,  因为递归，即使当前是对应位置，如果下一轮所有方向都找不到对应的匹配字符，当前Length--，[row * cols + col] = false，回退

## [3. 无重复字符的最长子串](https://github.com/artintel/LeetCode/blob/master/3.%20%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/source_code.cpp)

> 给定一个字符串，请你找出其中不含有重复字符的 **最长子串** 的长度。
>
> ```
> 输入: s = "abcabcbb"
> 输出: 3 
> 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
> 
> 输入: s = "bbbbb"
> 输出: 1
> 解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
> 
> 输入: s = "pwwkew"
> 输出: 3
> 解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
>      请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
> 
> 输入: s = ""
> 输出: 0
> ```

> 采用了动态规划算法，当查询当前位置时，以 `dp[i - 1]` 的长度为准，即前一个字符，前一个字符作为最长无重复子串的末尾，遍历完前一个字符所代表的最长字串，如果没有字符和当前字符相等，那么 `dp[i] = dp[i - 1] + 1`, 否则，如遇到有和自己相同的字符，那么通过前最长子串的长度 - interval + 1 即为 dp[i] 的值。其中 
>
> `interval`: 从 `s[i - 1]` 开始往前走，每走一格 `interval = dp[i - 1] - 1;`
>
> ```cpp
> for(int i = 1; i <= n ; i++){
> 	if( i == 1 ) {
> 		MAX = max(MAX, dp[i]);
> 		continue;
> 	}
> 	int interval = dp[i - 1];
> 	int j = i - 1;
> 	while(interval > 0){
> 		if(s[i - 1] != s[j - 1]){
> 			j--;
> 			interval--;
> 		}
> 	else break;
> 	}
> 	if(interval == 0) dp[i] = dp[i - 1] + 1;
> 	else dp[i] = dp[i - 1] - interval + 1;
> 	MAX = max(MAX, dp[i]);
> }
> ```

## [剑指 Offer 13. 机器人的运动范围](https://github.com/artintel/LeetCode/blob/master/%E5%89%91%E6%8C%87%20Offer%2013.%20%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/source_code.cpp)

> 地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？
>
> ```
> 输入：m = 2, n = 3, k = 1
> 输出：3
> 
> 输入：m = 3, n = 1, k = 0
> 输出：1
> ```

> 回溯算法：机器人从坐标 (0, 0) 开始移动。当它准备进入坐标为 (i, j) 的格子时，通过检查坐标的数位和来判断机器人是否能够进入。如果机器人能够进入坐标为 (i, j) 的格子，则再判断它能否进入 4 个相邻的格子 (i, j - 1), (i, j + 1), (i - 1, j), (i + 1, j)。
>

## [22. 括号生成](https://github.com/artintel/LeetCode/blob/master/22.%20%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/source_code.cpp)

> 数字 *n* 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。
>
> ```
> 输入：n = 3
> 输出：[
>        "((()))",
>        "(()())",
>        "(())()",
>        "()(())",
>        "()()()"
>      ]
> ```

> 回溯算法

## [剑指 Offer 14-I. 剪绳子](https://github.com/artintel/LeetCode/blob/master/%E5%89%91%E6%8C%87%20Offer%2014%20-%20I.%20%E5%89%AA%E7%BB%B3%E5%AD%90/source_code.cpp)

> 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
>
> ```
> 输入: 2
> 输出: 1
> 解释: 2 = 1 + 1, 1 × 1 = 1
> 
> 输入: 10
> 输出: 36
> 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
> ```

> 贪心算法：
>
> 尽可能多地剪去长度为 3 的绳子段。
>

## [剑指 Offer 14-II. 剪绳子](https://github.com/artintel/LeetCode/blob/master/%E5%89%91%E6%8C%87%20Offer%2014%20-%20II.%20%E5%89%AA%E7%BB%B3%E5%AD%90/source_code.cpp)

> 给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n>1并且m>1），每段绳子的长度记为 k[0],k[1]...k[m - 1] 。请问 k[0]*k[1]*...*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
>
> 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
>
> ```
> 输入: 2
> 输出: 1
> 解释: 2 = 1 + 1, 1 × 1 = 1
> 
> 输入: 10
> 输出: 36
> 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36
> ```

> 贪心算法：
>
> 注意内存边界
>
> ```C++
> long long result_3 = 1;
> long long result_2 = 1;
> for(int i = 1; i <= timesOf3; i++){
>     result_3 = 3 * result_3 % 1000000007;
> }
> for(int j = 1; j <= timesOf2; j++){
>     result_2 = 2 * result_2 % 1000000007;
> }
> 
> return (int)result_2 * result_3 % 1000000007;
> ```
>

## [46. 全排列](https://github.com/artintel/LeetCode/blob/master/46.%20%E5%85%A8%E6%8E%92%E5%88%97/source_code.cpp)

> 给定一个 **没有重复** 数字的序列，返回其所有可能的全排列
>
> ```
> 输入: [1,2,3]
> 输出:
> [
>   [1,2,3],
>   [1,3,2],
>   [2,1,3],
>   [2,3,1],
>   [3,1,2],
>   [3,2,1]
> ]
> ```

> DFS(回溯)：
>
> 做这道题我遇到的问题：
>
> 知道会用到回溯，DFS的思想，但是代码写不出来。主要原因在于不知道在何处写递归算法
>
> 定义变量：
>
> - `vector<vector<int>> ans;`
> - `vector<int> stack`;
> - `int length = nums.size();`
> - `vector<bool> flag(length, false);`
>
> `depth` 代表的遍历的层数，该题可以理解为对一颗树的深度遍历
>
> DFS:
>
> ```cpp
> void dfs(vector<int>& nums,vector<vector<int>>& ans,vector<bool>& flag, vector<int>& temp, int length, int depth){
> 	if( depth == length ) { // 深度到达最低一层，边界条件
>             ans.emplace_back(temp);
>             return;
>         }
>      for(int i = 0; i < length; i++){
>           if( flag[i] == true ) continue; // 如果已经进入 temp_stack，跳过
>           temp.emplace_back(nums[i]); // 否则，进入 temp_stack
>           flag[i] = true; // 置 flag[i] = true; 代表已经遍历
>           dfs(nums, ans, flag, temp, length, depth + 1);// 进入下一层，很重要，我就是不知道在这里
>           temp.pop_back();// 递归结束的返回点
>           flag[i] = false;// 将当前置为 false, 未遍历
>      }
> }
> ```
>

## [剑指 Offer 15. 二进制中 1 的个数](https://github.com/artintel/LeetCode/blob/master/%E5%89%91%E6%8C%87%20Offer%2015.%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD%201%20%E7%9A%84%E4%B8%AA%E6%95%B0/source_code.cpp)

> 请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。
>
> ```
> 输入：00000000000000000000000000001011
> 输出：3
> 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
> ```

> 位运算之 -- 与运算和左移操作
>

## [剑指 Offer 56 - I. 数组中数字出现的次数](https://github.com/artintel/LeetCode/blob/master/%E5%89%91%E6%8C%87%20Offer%2056%20-%20I.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/source_code.cpp)

> 一个整型数组 `nums` 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。
>
> ```
> 输入：nums = [4,1,4,6]
> 输出：[1,6] 或 [6,1]
> 
> 输入：nums = [1,2,10,4,1,4,3,3]
> 输出：[2,10] 或 [10,2]
> ```

> 位运算之 -- 异或运算
>
> 遍历所有的数字并进行异或运算，最后得到的结果和两个只出现一次的异或运算结果相同。此时通过 1 并且左移的情况找到异或结果中第一个不为 0 的位置(数位不同时进行异或的结果为 1 )
>
> 以此为基准，将数组分为 a, b 两组，并通过这个不为 0 的位置进行异或，这两个不同的数字必定被分在不同的组，而其他出现两次的数字必定分在同一个组，因为异或，出现两次的数字异或结果为 0

## [49. 字母异位词分组](https://github.com/artintel/LeetCode/blob/master/49.%20%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/source_code.cpp)

> 给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。
>
> ```
> 输入: ["eat", "tea", "tan", "ate", "nat", "bat"]
> 输出:
> [
>   ["ate","eat","tea"],
>   ["nat","tan"],
>   ["bat"]
> ]
> ```

> 由于互为字母异位词的两个字符串包含的字母相同，因此对两个字符串分别进行排序之后得到的字符串一定是相同的，故可以将排序之后的字符串作为哈希表的键。

## [剑指 Offer 16. 数值的整数次方](https://github.com/artintel/LeetCode/blob/master/%E5%89%91%E6%8C%87%20Offer%2016.%20%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/source_code.cpp)

> 实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。
>

## [62. 不同路径](https://github.com/artintel/LeetCode/blob/master/62.%20%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/source_code.cpp)

> 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。
>
> 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。
>
> 问总共有多少条不同的路径？
>
> ```
> 输入：m = 3, n = 7
> 输出：28
> 
> 输入：m = 3, n = 2
> 输出：3
> 解释：
> 从左上角开始，总共有 3 条路径可以到达右下角。
> 1. 向右 -> 向右 -> 向下
> 2. 向右 -> 向下 -> 向右
> 3. 向下 -> 向右 -> 向右
> 
> 输入：m = 7, n = 3
> 输出：28
> 
> 输入：m = 3, n = 3
> 输出：6
> ```

> 解法1：动态规划 `dp[i][j] = dp[i - 1][j] + dp[i][j - 1];`
>
> 解法2：组合数学
>
> 从左上角到右下角的过程中，我们需要移动 m+n-2m+n−2 次，其中有 m-1m−1 次向下移动，n-1n−1 次向右移动。因此路径的总数，就等于从 m+n-2m+n−2 次移动中选择 m-1m−1 次向下移动的方案数，即组合数：C(m - 1, m + n - 2)
>
> 作者：LeetCode-Solution
> 链接：https://leetcode-cn.com/problems/unique-paths/solution/bu-tong-lu-jing-by-leetcode-solution-hzjf/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## [101. 对称二叉树](https://github.com/artintel/LeetCode/blob/master/101.%20%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/source_code.cpp)

> 给定一个二叉树，检查它是否是镜像对称的。
>
> ```
> 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。
> 
> 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:
> ```

> 解法1：递归
>
> 如果一个树的左子树与右子树镜像对称，那么这个树是对称的。
>
> 因此，该问题可以转化为：两个树在什么情况下互为镜像？
>
> 如果同时满足下面的条件，两个树互为镜像：
>
> - 它们的两个根结点具有相同的值
> - 每个树的右子树都与另一个树的左子树镜像对称
>
> 我们可以实现这样一个递归函数，通过「同步移动」两个指针的方法来遍历这棵树，p 指针和 q 指针一开始都指向这棵树的根，随后 p 右移时，q 左移，p 左移时，q 右移。每次检查当前 p 和 q 节点的值是否相等，如果相等再判断左右子树是否对称。
>
> 作者：LeetCode-Solution
> 链接：https://leetcode-cn.com/problems/symmetric-tree/solution/dui-cheng-er-cha-shu-by-leetcode-solution/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
>
> 解法2：迭代
>
> 首先引入一个队列，这是把递归程序改写成迭代程序的常用方法。初始化时把根节点入队两次。每次提取两个结点并比较它们的值（队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像），然后将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。
>
> 作者：LeetCode-Solution
> 链接：https://leetcode-cn.com/problems/unique-paths/solution/bu-tong-lu-jing-by-leetcode-solution-hzjf/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## [136. 只出现一次的数字](https://github.com/artintel/LeetCode/blob/master/136.%20%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/source_code.cpp)

> 给定一个**非空**整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
>
> 不使用额外空间来实现
>
> ```
> 输入: [2,2,1]
> 输出: 1
> ```

> 如果没有时间复杂度和空间复杂度的限制，这道题有很多种解法，可能的解法有如下几种。
>
> - 使用集合存储数字。遍历数组中的每个数字，如果集合中没有该数字，则将该数字加入集合，如果集合中已经有该数字，则将该数字从集合中删除，最后剩下的数字就是只出现一次的数字。
>
> - 使用哈希表存储每个数字和该数字出现的次数。遍历数组即可得到每个数字出现的次数，并更新哈希表，最后遍历哈希表，得到只出现一次的数字。
>
> - 使用集合存储数组中出现的所有数字，并计算数组中的元素之和。由于集合保证元素无重复，因此计算集合中的所有元素之和的两倍，即为每个元素出现两次的情况下的元素之和。由于数组中只有一个元素出现一次，其余元素都出现两次，因此用集合中的元素之和的两倍减去数组中的元素之和，剩下的数就是数组中只出现一次的数字。
>
> 上述三种解法都需要额外使用 O(n) 的空间，其中 n 是数组长度。如果要求使用线性时间复杂度和常数空间复杂度，上述三种解法显然都不满足要求。那么，如何才能做到线性时间复杂度和常数空间复杂度呢？
>
> 答案是使用位运算。对于这道题，可使用异或运算 \oplus⊕。异或运算有以下三个性质。
>
> 作者：LeetCode-Solution
> 链接：https://leetcode-cn.com/problems/single-number/solution/zhi-chu-xian-yi-ci-de-shu-zi-by-leetcode-solution/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## [64. 最小路径和](https://github.com/artintel/LeetCode/blob/master/64.%20%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/source_code.cpp)

> 给定一个包含非负整数的 `m x n` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
>
> **说明：**每次只能向下或者向右移动一步。
>
> ```
> 输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
> 输出：7
> 解释：因为路径 1→3→1→1→1 的总和最小。
> ```

> DP算法；二维数组中的每一个都保存了所有方向到该方向的最小路径和

## [剑指 Offer 21. 调整数组顺序使奇数位于偶数前面](https://github.com/artintel/LeetCode/blob/master/%E5%89%91%E6%8C%87%20Offer%2021.%20%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/source_code.cpp)

> 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。
>
> ```
> 输入：nums = [1,2,3,4]
> 输出：[1,3,2,4] 
> 注：[3,1,2,4] 也是正确的答案之一。
> ```

## [78. 子集](https://github.com/artintel/LeetCode/blob/master/78.%20%E5%AD%90%E9%9B%86/source_code.cpp)

> 给你一个整数数组 `nums` ，返回该数组所有可能的子集（幂集）。解集不能包含重复的子集。
>
> ```
> 输入：nums = [1,2,3]
> 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
> 
> 输入：nums = [0]
> 输出：[[],[0]]
> ```

> **方法一：迭代法实现子集枚举**
> 思路与算法
>
> 记原序列中元素的总数为 n。原序列中的每个数字 $a_i$ 的状态可能有两种，即「在子集中」和「不在子集中」。我们用 1 表示「在子集中」，0 表示不在子集中，那么每一个子集可以对应一个长度为 n 的 0/1 序列，第 i 位表示 $a_i$
> 	
> 是否在子集中。例如，$n = 3, a = \{ 5, 2, 9 \} $时：
>
> | 0 / 1 序列 | 子集        | 0 / 1 序列对应的二进制数 |
> | ---------- | ----------- | ------------------------ |
> | 000        | {}          | 0                        |
> | 001        | {9}         | 1                        |
> | 010        | {2}         | 2                        |
> | 011        | {2，9}      | 3                        |
> | 100        | {5}         | 4                        |
> | 101        | {5， 9}     | 5                        |
> | 110        | {5， 2}     | 6                        |
> | 111        | {5， 2， 9} | 7                        |
>
> 可以发现 $0/1$ 序列对应的二进制数正好从 $ 0 $ 到 $2^n - 1$。我们可以枚举 $mask∈[0,2 n−1]$，mask 的二进制表示是一个 $0/1$ 序列，我们可以按照这个 $0/1$ 序列在原集合当中取数。当我们枚举完所有 $2^n$个 mask，我们也就能构造出所有的子集。
>
> **方法二：递归法实现子集枚举**
>
> 用递归来实现子集枚举。
>
> 假设我们需要找到一个长度为 n*n* 的序列 a*a* 的所有子序列，代码框架是这样的：
>
> ```
> vector<int> t;
> void dfs(int cur, int n) {
>     if (cur == n) {
>         // 记录答案
>         // ...
>         return;
>     }
>     // 考虑选择当前位置
>     t.push_back(cur);
>     dfs(cur + 1, n, k);
>     t.pop_back();
>     // 考虑不选择当前位置
>     dfs(cur + 1, n, k);
> }
> ```
>
> 上面的代码中，$dfs(cur,n)$ 参数表示当前位置是 $cur$，原序列总长度为 $n$。原序列的每个位置在答案序列中的状态有被选中和不被选中两种，我们用 $t$ 数组存放已经被选出的数字。在进入 $dfs(cur,n)$ 之前 $[0,cur−1]$ 位置的状态是确定的，而 $[cur,n−1] $内位置的状态是不确定的，$dfs(cur,n)$ 需要确定 $cur$ 位置的状态，然后求解子问题 $dfs(cur+1,n)$。对于 $cur$ 位置，我们需要考虑 $a[cur]$ 取或者不取，如果取，我们需要把 $a[cur]$ 放入一个临时的答案数组中（ 即上面代码中的 $t$ ），再执行 $dfs(cur+1,n)$，执行结束后需要对 $t$ 进行回溯；如果不取，则直接执行 $dfs(cur+1,n)$。在整个递归调用的过程中，$cur$ 是从小到大递增的，当 $cur$ 增加到 $n$ 的时候，记录答案并终止递归。可以看出二进制枚举的时间复杂度是 $O(2 ^ n$)
>
> 作者：LeetCode-Solution
> 链接：https://leetcode-cn.com/problems/subsets/solution/zi-ji-by-leetcode-solution/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## [206. 反转链表](https://github.com/artintel/LeetCode/blob/master/206.%20%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/source_code.cpp)

> 递归和迭代思想是一样的，这里说递归
>
> 1. 递归边界条件 `if( head->next == nullptr ) return head;`
>
> 2. 递归体 `dfs(head->next);`
>
> 3. 递归体结束，说明当前节点之后的链表都已经发生了反转，那么执行 
>
>    `dfs(head->next)->next = head;`
>
>    `return head;`
>
> 上代码解释：
>
> ```cpp
> class Solution {
> public:
>     LinkNode* dfs( LinkNode* head ){
>         if( head->next == nullptr ){ //边界条件
>             return head;
>         }
>         dfs(head->next)->next = head; // 递归返回的是当前节点之后已经反转好的链表最后一个节点
>         						    // 所以会通过 将 dfs(...)的返回节点的next指向当前节点
>          						    // 完成当前节点的反转
>         head->next = nullptr;		  // 最后将当前的 next 置为 nullptr;
>         return head;
>     }
>     LinkNode* reverse( LinkNode* head ){
>         if(head == nullptr) return nullptr;
>         if(head->next == nullptr ) return head;
>         LinkNode* temp = head;
>         while(temp->next){ // 考虑到main()的验证，通过while找到原始链表的最后一个节点
>             temp = temp->next;
>         }
>         dfs(head);
>         return temp; // 返回原始链表的最后一个节点，也是反转后的头节点；
>     }
> };
> ```
>

## [47. 全排列 II](https://github.com/artintel/LeetCode/blob/master/47.%20%E5%85%A8%E6%8E%92%E5%88%97%20II/source_code.cpp)

> 给定一个可包含重复数字的序列 `nums` ，**按任意顺序** 返回所有不重复的全排列。
>
> ```cpp
> 输入：nums = [1,1,2]
> 输出：
> [[1,1,2],
>  [1,2,1],
>  [2,1,1]]
>     
> 输入：nums = [1,2,3]
> 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
> ```

> 要解决重复问题，我们只要设定一个规则，保证在填第 idx 个数的时候重复数字只会被填入一次即可。而在本题解中，我们选择对原数组排序，保证相同的数字都相邻，然后每次填入的数一定是这个数所在重复数集合中「从左往右第一个未被填过的数字」，即如下的判断条件：
>
> ```cpp
> if (i > 0 && nums[i] == nums[i - 1] && !flag[i - 1]) {
>     continue;
> }
> ```
>
>
> 这个判断条件保证了对于重复数的集合，一定是从左往右逐个填入的。
>
> 假设我们有 3 个重复数排完序后相邻，那么我们一定保证每次都是拿从左往右第一个未被填过的数字，即整个数组的状态其实是保证了 [未填入，未填入，未填入] 到 [填入，未填入，未填入]，再到 [填入，填入，未填入]，最后到 [填入，填入，填入] 的过程的，因此可以达到去重的目标。
>
> 作者：LeetCode-Solution
> 链接：https://leetcode-cn.com/problems/permutations-ii/solution/quan-pai-lie-ii-by-leetcode-solution/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## [79. 单词搜索](https://github.com/artintel/LeetCode/blob/master/79.%20%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/source_code.cpp)

> 给定一个二维网格和一个单词，找出该单词是否存在于网格中。
>
> 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。
>
> ```cpp
> board =
> [
>   ['A','B','C','E'],
>   ['S','F','C','S'],
>   ['A','D','E','E']
> ]
> 
> 给定 word = "ABCCED", 返回 true
> 给定 word = "SEE", 返回 true
> 给定 word = "ABCB", 返回 false
> ```

> 回溯算法：
>
> 1. 二维网格当前字符和单词对应位置的字符相等，`length++, flag[row x cols + col] = true`，并且迭代之后四个方向，查询`board[i][j] == word[length] ?`
> 2. 如果四个方向都不能和单词之后的单词对应，那么 `length--, flag[row x cols + col] = false;`
>
> 边界条件：
>
> ```cpp
> if(length == n) return true;
>         if(row < 0 || col < 0 || row >= rows || col >= cols || flag[row * cols + col] == true || board[row][col] != word[length]) return false;
> ```
>
> 因为找的是网格中是否存在有路径使得对应的上单词
>
> ```cpp
> for(int i = 0; i < m; i++){
>     for(int j = 0; j < n; j++){
>         if(trace_back(board, word, flag, i, j, m, n, 0, Length)){ //从不同的位置进行查询
>             return true;
>         }
>     }
> }
> ```
>

## [89. 格雷编码](https://github.com/artintel/LeetCode/blob/master/89.%20%E6%A0%BC%E9%9B%B7%E7%BC%96%E7%A0%81/source_code.cpp)

> 格雷编码是一个二进制数字系统，在该系统中，两个连续的数值仅有一个位数的差异。
>
> 给定一个代表编码总位数的非负整数 n，打印其格雷编码序列。即使有多个不同答案，你也只需要返回其中一种。
>
> 格雷编码序列必须以 0 开头。
>
> ```cpp
> 输入: 2
> 输出: [0,1,3,2]
> 解释:
> 00 - 0
> 01 - 1
> 11 - 3
> 10 - 2
> 
> 对于给定的 n，其格雷编码序列并不唯一。
> 例如，[0,2,3,1] 也是一个有效的格雷编码序列。
> 
> 00 - 0
> 10 - 2
> 11 - 3
> 01 - 1
>     
>     输入: 0
> 输出: [0]
> 解释: 我们定义格雷编码序列必须以 0 开头。
>      给定编码总位数为 n 的格雷编码序列，其长度为 2n。当 n = 0 时，长度为 20 = 1。
>      因此，当 n = 0 时，其格雷编码序列为 [0]。
> ```

> 公式：
>
> - 设 n 阶格雷码集合为 G(n)，则 G(n+1) 阶格雷码为：
>   - 给 G(n) 阶格雷码每个元素二进制形式前面添加 0，得到 G'(n)；
>   - 设 G(n) 集合倒序（镜像）为 R(n)，给 R(n) 每个元素二进制形式前面添加 1，得到 R'(n)；
>   - G(n+1) = G'(n) ∪ R'(n) 拼接两个集合即可得到下一阶格雷码。
> - 根据以上规律，可从 0 阶格雷码推导致任何阶格雷码。
> - 代码解析：
>   - 由于最高位前默认为 0，因此 G'(n) = G(n)，只需在 res(即 G(n) )后添加 R'(n)即可；
>   - 计算 R'(n) 执行 head = 1 << i 计算出对应位数，以给 R(n) 前添加 1 得到对应 R'(n)
>   - 倒序遍历 res(即 G(n) )：依次求得 R'(n)各元素添加至 res 尾端，遍历完成后 res(即 G(n+1)G(n+1))。
>
> 作者：jyd
> 链接：https://leetcode-cn.com/problems/gray-code/solution/gray-code-jing-xiang-fan-she-fa-by-jyd/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## [90. 子集 II](https://github.com/artintel/LeetCode/blob/master/90.%20%E5%AD%90%E9%9B%86%20II/source_code.cpp)

> 给定一个可能包含重复元素的整数数组 ***nums***，返回该数组所有可能的子集（幂集）。
>
> **说明：**解集不能包含重复的子集。
>
> ```
> 输入: [1,2,2]
> 输出:
> [
>   [2],
>   [1],
>   [1,2,2],
>   [2,2],
>   [1,2],
>   []
> ]
> ```

## [剑指 Offer 29. 顺时针打印矩阵](https://github.com/artintel/LeetCode/blob/master/%E5%89%91%E6%8C%87%20Offer%2029.%20%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/source_code.cpp)

> 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。
>
> ```
> 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
> 输出：[1,2,3,6,9,8,7,4,5]
>     
> 输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
> 输出：[1,2,3,4,8,12,11,10,9,5,6,7]
> ```

## [93. 复原IP地址](https://github.com/artintel/LeetCode/blob/master/93.%20%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80/source_code.cpp)

> 给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。
>
> 有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 '.' 分隔。
>
> ```
> 例如："0.1.2.201" 和 "192.168.1.1" 是 有效的 IP 地址，但是 "0.011.255.245"、"192.168.1.312" 和 "192.168@1.1" 是 无效的 IP 地址。
> ```

> 由于我们需要找出所有可能复原出的 `IP` 地址，因此可以考虑使用递归的方法，对所有可能的字符串分隔方式进行搜索，并筛选出满足要求的作为答案。
>
> 设题目中给出的字符串为 `s`。我们用递归函数 `dfs(segId,segStart)` 表示我们正在从 `s[segStart]` 的位置开始，搜索 `IP` 地址中的第 `segId` 段，其中 `segId∈{0,1,2,3}` 。由于 IP 地址的每一段必须是 `[0,255]` 中的整数，因此我们从 `segStart` 开始，从小到大依次枚举当前这一段 IP 地址的结束位置 `segEnd`。如果满足要求，就递归地进行下一段搜索，调用递归函数 `dfs(segId+1,segEnd+1)`。
>
> 特别地，由于 `IP` 地址的每一段不能有前导零，因此如果 `s[segStart]` 等于字符 `0`，那么 `IP` 地址的第 `segId` 段只能为 0，需要作为特殊情况进行考虑。
>
> 在递归搜索的过程中，如果我们已经得到了全部的 `4` 段 `IP` 地址（ 即 `segId=4` ），并且遍历完了整个字符串（即 `segStart=|s|`，其中 `|s|` 表示字符串 `s` 的长度），那么就复原出了一种满足题目要求的 `IP` 地址，我们将其加入答案。在其它的时刻，如果提前遍历完了整个字符串，那么我们需要结束搜索，==回溯==到上一步。
>
> 作者：LeetCode-Solution
> 链接：https://leetcode-cn.com/problems/restore-ip-addresses/solution/fu-yuan-ipdi-zhi-by-leetcode-solution/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## [剑指 Offer 30. 包含min函数的栈](https://github.com/artintel/LeetCode/blob/master/%E5%89%91%E6%8C%87%20Offer%2030.%20%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/source_code.cpp)

> 定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。
>
> ```
> MinStack minStack = new MinStack();
> minStack.push(-2);
> minStack.push(0);
> minStack.push(-3);
> minStack.min();   --> 返回 -3.
> minStack.pop();
> minStack.top();      --> 返回 0.
> minStack.min();   --> 返回 -2.
> ```

> 解题的唯一难点在于理解 O(1)，所以我们可以使用辅助栈来保存最小值的关系
>
> ```c
> if(x < minstack.top()) x 入辅助栈
> else minstack.top() 再入辅助栈
> x 正常如栈
> ```

## [剑指 Offer 31. 栈的压入、弹出序列](https://github.com/artintel/LeetCode/blob/master/%E5%89%91%E6%8C%87%20Offer%2031.%20%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/source_code.cpp)

> 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。
>
> ```
> 输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]
> 输出：true
> 解释：我们可以按以下顺序执行：
> push(1), push(2), push(3), push(4), pop() -> 4,
> push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1
> 
> 输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]
> 输出：false
> 解释：1 不能在 2 之前弹出。
> ```

> 思路：初始化一个中间栈，按给出的压栈顺序进行压栈。在进行压栈操作的时候需要查看当前值和压出栈的对应关系:
>
> - popped[index] == stack.top() ? 如果是，stack.pop(), index++；如果不是继续下一个比较
> - popped[index] == pushed[i],  i++, index++, 不进行压栈操作。
> - popped[index] != pushed[i], pushed[i] 入栈， i++;
>
> 边界条件：当 i == popped.size(), 说明已经遍历结束，即压栈结束
>
> 如果此时 stack 为空，说明刚好匹配，可直接 return true;
>
> 否则
>
> ```cpp
> while(!stack.empty()){
>     if( stack.top() == popped[index] ){ // 出栈入栈顺序匹配；
>         stack.pop();
>         index++; // 查看接下来的出栈入栈值是否匹配
>     }
>     else return false; // 一旦不等，直接返回 false;
> }
> return true;
> ```

## [131. 分割回文子串](https://github.com/artintel/LeetCode/blob/master/131.%20%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/source_code.cpp)

> 给定一个字符串 *s*，将 *s* 分割成一些子串，使每个子串都是回文串。
>
> 返回 *s* 所有可能的分割方案。
>
> ```
> 输入: "aab"
> 输出:
> [
>   ["aa","b"],
>   ["a","a","b"]
> ]
> ```

> 回溯三部曲：
>
> - 递归函数参数
>
>   全局变量数组path存放切割后回文的子串，二维数组result存放结果集。 （这两个参数可以放到函数参数里）
>
>   ```cpp
>   vector<vector<string>> result;
>   vector<string> path;
>   void backtracking( const string& s, int startIndex ){}
>   ```
>
> - 终止条件
>
>   ```cpp
>   void backtracking (const string& s, int startIndex) {
>       // 如果起始位置已经大于s的大小，说明已经找到了一组分割方案了
>       if (startIndex >= s.size()) {
>           result.push_back(path);
>           return;
>       }
>   }
>   ```
>
>   在 `for (int i = startIndex; i < s.size(); i++)` 循环中，我们定义了起始位置 `startIndex`，那么 `[startIndex, i]` 就是要截取的子串。
>
>   首先判断这个子串是不是回文，如果是回文，就加入在`vector<string> path`中，path用来记录切割过的回文子串。
>
>   ```cpp
>   for (int i = startIndex; i < s.size(); i++) {
>       if (isPalindrome(s, startIndex, i)) { // 是回文子串
>           // 获取[startIndex,i]在s中的子串
>           string str = s.substr(startIndex, i - startIndex + 1);
>           path.push_back(str);
>       } else {                // 如果不是则直接跳过
>           continue;
>       }
>       backtracking(s, i + 1); // 寻找i+1为起始位置的子串
>       path.pop_back();        // 回溯过程，弹出本次已经填在的子串
>   }
>   ```
>
>   **注意切割过的位置，不能重复切割，所以，backtracking(s, i + 1); 传入下一层的起始位置为i + 1**
>
> - 回溯算法模板
>
>   ```Cpp
>   void backtracking(参数) {
>       if (终止条件) {
>           存放结果;
>           return;
>       }
>   
>       for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
>           处理节点;
>           backtracking(路径，选择列表); // 递归
>           回溯，撤销处理结果
>       }
>   }
>   ```
>
>   作者：carlsun-2
>   链接：https://leetcode-cn.com/problems/palindrome-partitioning/solution/131-fen-ge-hui-wen-chuan-hui-su-sou-suo-suan-fa-xi/
>   来源：力扣（LeetCode）
>   著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。